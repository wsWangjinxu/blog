<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript类型的细节 | 似水年华</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript类型的细节</h1><a id="logo" href="/.">似水年华</a><p class="description">山水之间，并无岁月；人之境遇，方有春秋</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript类型的细节</h1><div class="post-meta">Apr 27, 2019<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span></div><div class="post-content"><h2 id="Undefined-与-Null"><a href="#Undefined-与-Null" class="headerlink" title="Undefined 与 Null"></a>Undefined 与 Null</h2><p>Undefined 类型表示未定义，它的类型只有一个值，就是 Undefined。任何变量在赋值前都是 Undefined 类型、值为 undefined，一般可以用全局变量 undefined 来表达这个值，或者用 void 运算将任意一个表达式变成 undefined 值。</p>
<p>因为 JavaScript 中 undefined 是一个变量，而并非一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，为了避免无意中被错改，建议使用<code>void 0</code>来获取 undefined 值。虽然现代浏览器都对这个变量的修饰符做了限定，不能修改，但是还是需要注意。</p>
<p>Null 类型也是只有一个值，就是 null，它的语义表示空值，<strong>表示定义了但是为空</strong>。与 undefined 不同，null 是 JavaScript 关键字，可以放心使用。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>JavaScript 中的字符是永远无法变更的，字符串一旦被构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。String 用于表示文本数据，String 有最大长度是<code>2^53 - 1</code>，这个在一般开发中是够用的，但是这个所谓的最大长度并不是我们理解中的字符数。因为 String 是字符串的 UTF-16 编码，我们字符串的操作<code>charAt</code>、<code>charCodeAt</code>、<code>length</code> 等方法针对的都是 UTF16 编码，所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p>
<blockquote>
<p>现行的字符集国际标准是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。Unicode 的码点通常用 U+码点 来表示，其中码点是十六进制的码点值。0-65535的码点被称为基本字符区域(BMP)。</p>
</blockquote>
<p>JavaScript 字符串把每个 UTF16 单元当作一个字符处理，所以超出 BMP 的字符时，应该格外小心。</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是为了表达几个额外的语言场景，规定了几个例外情况：</p>
<ul>
<li>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字</li>
<li>Infinity，无穷大</li>
<li>-Infinity，负无穷大</li>
</ul>
<p>另外，值得注意的是 +0 和 -0， 在加法运算中它们没有区别，但是除法的场合则需要特别留意区分，区分 +0 或 -0 的方式是检测 <code>1/x</code> 的结果是 Infinity 还是 -Infinity。</p>
<p>根绝双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。非整数的 Number 类型无法用 == 和 === 比较大小。这是浮点运算的特点，浮点运算的精度问题导致等式左右的结果并不是严格相等，而是相差了微小的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误的比较方法</span><br><span class="line">0.1 + 0.2 == 0.3 // false</span><br><span class="line"></span><br><span class="line">// 正确的比较方法</span><br><span class="line">Math.abs(0.1 + 0.2 -0.3) &lt;= Number.EPSILON // true 表示相等</span><br></pre></td></tr></table></figure>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是 ES6 中引入的新类型，它是一切字符串的对象key的集合，在 ES6 规范中国，整个对象系统被用 Symbol 重塑。这里只关注类型本身。</p>
<p>Symbol 可以具有字符串类型的描述，但是即使描述是相同的，Symbol 也不相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 使用全局 Symbol 函数创建 Symbol</span><br><span class="line">var mySymbol = Symbol(&quot;symbol description&quot;);</span><br><span class="line"></span><br><span class="line">// 使用 Symbol.iterator 来定义 for...of 在对象上的行为</span><br><span class="line">var o = new Object</span><br><span class="line">o[Symbol.iterator] = function () &#123;</span><br><span class="line">    var v = 0</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function () &#123;</span><br><span class="line">            return &#123; value: v++, done: v &gt; 10 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (var v of o) &#123;</span><br><span class="line">    console.log(v); // 0, 1 ... 9</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中定义了 iterator 之后，用 for (var v of o) 就可以调用这个函数，然后可以根据函数的行为，产生一个 for ... of 的行为。</span><br></pre></td></tr></table></figure>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 的结构，key 可以是字符串或者 Symbol 类型。</p>
<p>JavaScript 中的几个基本类型的构造器：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>
<p>前三个是两用的，当跟 new 搭配的时候，产生对象，当直接调用时，它们表示强制类型转换。</p>
<p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p>
<p>JavaScript 语言设计上试图模糊对象和基本类型之间的关系，日常中可以把对象的方法在基本类型上使用，甚至在原型上添加的方法，都可以应用于基本类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在基本类型上调用方法</span><br><span class="line">console.log(&quot;abc&quot;.charAt(0)); // a</span><br><span class="line"></span><br><span class="line">// 在 Symbol 原型上添加方法，在任何 Symbol 类型变量都可以调用</span><br><span class="line">Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">var a = Symbol(&quot;a&quot;);</span><br><span class="line">console.log(typeof a); // symbol，a 并非对象</span><br><span class="line">a.hello(); // hello，有效</span><br></pre></td></tr></table></figure>
<p><code>.</code>运算符提供了装箱操作，它会根据基础类型构造一个临时的包装对象，使得我们能在基础类型上调用对应对象的方法。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算符会先进行类型转换。大部分类型转换符合直觉，但是如果不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。</p>
<p>类型转换规则表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|         |    Null   |  Undefined  | Boolean(True) | Boolean(False) |      Number    |     String     |  Symbol   | Object |</span><br><span class="line">| ------- | --------- | ----------- | ------------- | -------------- | -------------- | -------------- | --------- | ------ |</span><br><span class="line">| Boolean |   FALSE   |    FALSE    |       -       |        -       |  0/NaN-false   |    &quot;&quot;-fase     |   TRUE    |  TRUE  |</span><br><span class="line">|  Number |     0     |      NaN    |       1       |        0       |       -        | StringToNumber | TypeError | 拆箱转换 |</span><br><span class="line">|  String |  &quot;null&quot;   | &quot;undefined&quot; |     TRUE      |      FALSE     | NumberToString |       -        | TypeError | 拆箱转换 |</span><br><span class="line">|  Object | TypeError |  TypeError  |    装箱转换    |      装箱转换    |     装箱转换    |     装箱转换    |  装箱转换   |   -    |</span><br></pre></td></tr></table></figure>
<p>在上面的表格中，较为复杂的是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。</p>
<h3 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h3><p>字符串到数字的类型转换，存在一个语法结构，类型转换支持支持十进制、二进制、八进制和十六进制，比如：</p>
<ul>
<li>30</li>
<li>0b111</li>
<li>0o13</li>
<li>0xFF</li>
</ul>
<p>此外，JavaScript 支持的字符串语法还包括科学计数法，可以使用大写或者小写 e 来表示：</p>
<ul>
<li>1e3</li>
<li>-1e-2</li>
</ul>
<p>需要注意的是，在 StringToNumber 的情况下，parseInt 和 parseFloat 在不传入参数的情况下，只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头 的数字作为 8 进制前缀，这是很多错误的涞源。所以，在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。</p>
<h3 id="NumnberToString"><a href="#NumnberToString" class="headerlink" title="NumnberToString"></a>NumnberToString</h3><p>在较小的范围内，数字到字符串的转换是完全符合直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示，保证了产生的字符串不会过长。</p>
<h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓的装箱转换，正是把基本类型转换为对应一个对象。全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 利用 call 方法来强制产生装箱</span><br><span class="line">var symbolObject = (function() &#123;return this;&#125;).call(Symbol(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">console.log(typeof symbolObject) // object</span><br><span class="line">console.log(symbolObject instanceof Symbol) // true</span><br><span class="line">console.log(symbolObject.constructor == Symbol) // true</span><br></pre></td></tr></table></figure>
<p>装箱机制会频繁产生临时对象，在一些性能要求较高的场景下，应该尽量避免对基本类型做装箱转换。</p>
<p>使用内置的 Object 函数，可以在 JavaScript 代码中显式调用装箱能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var symbolObject = Object(Symbol(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(symbolObject)); // [Object Symbol]</span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p>
<h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。对象到 String 和 Number 的转换都是把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p>
<p>拆箱转换都会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 到 Number 的拆箱转换</span><br><span class="line">var o = &#123;</span><br><span class="line">    valueOf: () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,</span><br><span class="line">    toString: () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0 * 2</span><br><span class="line"></span><br><span class="line">// valueOf</span><br><span class="line">// toString</span><br><span class="line">// TypeError</span><br><span class="line"></span><br><span class="line">// 到 String 的拆箱转换</span><br><span class="line"></span><br><span class="line">String(o)</span><br><span class="line"></span><br><span class="line">// toString</span><br><span class="line">// valueOf</span><br><span class="line">// TypeError</span><br></pre></td></tr></table></figure>
<p>这里调用 toString 与 调用 valueOf 的顺序，与规范中的内部实现有关。规范指出，类型转换的内部实现是通过<code>ToPrimitive (input [, PreferredType])</code>方法进行转换的，这个方法的作用就是将 input 转换成一个非对象类型。参数 preferredType 进来，默认的是“number”，如果值是“string”，那就先执行“toString”，后执行“valueOf”，如果参数是“string”，则调换顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 规范中加法操作没有传递值，所以默认参数“number”起效</span><br><span class="line">o + &quot;string&quot;</span><br><span class="line"></span><br><span class="line">// valueOf</span><br><span class="line">// toString</span><br><span class="line">// TypeError</span><br></pre></td></tr></table></figure>
<p>在 ES6 之后，允许对象通过显示指定 @@toPrimitive Symbol 来覆盖原有的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    valueOf: () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,</span><br><span class="line">    toString: () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[Symbol.toPrimitive] = () =&gt; &#123;console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(o + &quot;&quot;)</span><br><span class="line"></span><br><span class="line">// toPrimitive</span><br><span class="line">// hello</span><br></pre></td></tr></table></figure>
<h3 id="运行时类型"><a href="#运行时类型" class="headerlink" title="运行时类型"></a>运行时类型</h3><p>运行时类型(标准中的规定)与 typeof 运算返回的操作数的类型比较</p>
<table>
<thead>
<tr>
<th>示例表达式</th>
<th>typeof 结果</th>
<th>运行时类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>object</td>
<td>Null</td>
</tr>
<tr>
<td>{}</td>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>(function(){})</td>
<td>function</td>
<td>Object</td>
</tr>
<tr>
<td>3</td>
<td>number</td>
<td>Number</td>
</tr>
<tr>
<td>“ok”</td>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>true</td>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>void 0</td>
<td>undefined</td>
<td>Undefined</td>
</tr>
<tr>
<td>Symbol(“a”)</td>
<td>symbol</td>
<td>Symbol</td>
</tr>
</tbody>
</table>
</div><div class="tags"><a href="/tags/类型/">类型</a></div><div class="post-nav"><a class="pre" href="/2019/05/05/Go命令源码文件/">Go 命令源码文件</a><a class="next" href="/2019/04/21/GOPATH和工作区/">GOPATH 和工作区</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '842d8ecfa6d0e5202966',
  clientSecret: '95bd57bae7fb2f91b3be577a9536c051df24a5e8',
  repo: 'blog',
  owner: 'wsWangjinxu',
  admin: ['wsWangjinxu'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/API/">API</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/浏览器/">浏览器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/前端路由/" style="font-size: 15px;">前端路由</a> <a href="/tags/Go语言学习笔记/" style="font-size: 15px;">Go语言学习笔记</a> <a href="/tags/二分查找/" style="font-size: 15px;">二分查找</a> <a href="/tags/闭包/" style="font-size: 15px;">闭包</a> <a href="/tags/webAPI/" style="font-size: 15px;">webAPI</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/类型/" style="font-size: 15px;">类型</a> <a href="/tags/RESTful/" style="font-size: 15px;">RESTful</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/11/【leetcode刷题笔记】1.二分查找的变种/">【leetcode刷题笔记】1.二分查找的变种</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/JS手写代码系列/">JS手写代码系列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/Gitflow学习笔记/">Gitflow学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/使用PM2管理你的node应用程序/">使用 PM2 管理你的 node 应用程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/常用页面尺寸与位置的获取/">常用页面尺寸与位置的获取</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/07/闭包的概念与应用/">闭包的概念与应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/19/谈谈前端路由/">谈谈前端路由</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/05/Go命令源码文件/">Go 命令源码文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/27/JavaScript类型的细节/">JavaScript类型的细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/GOPATH和工作区/">GOPATH 和工作区</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://jackiecookie.github.io" title="jackiecookie" target="_blank">jackiecookie</a><ul></ul><a href="http://eightythousand.com/" title="手辰" target="_blank">手辰</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">似水年华.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>