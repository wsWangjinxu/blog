---
title: 算法笔记
tags: 算法
---

#### 用空间换时间的设计思想

当内存空间充足的时候，如果追求代码的执行速度，可以选择空间复杂度相对高，但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如泡在单片机上，这个时候要反过来，用时间换空间的设计思路。

缓存实际上就是利用了空间换时间的设计思想，如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但每次数据查询的速度就大大提高了

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

### 链表与数组性能比较

数组与链表是两种截然不同的内存组织方式。正因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。

数组与链表的对比，并不能局限于时间复杂度。在实际的软件开发中，不能仅仅利用复杂度分析就决定使用那个数据结构来存储数据。

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果生命的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足。如果生命数组过小，则可能造成不够用的情况。这是只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。

除此之外，如果代码对内存的使用非常苛刻，那数组更适合，因为链表中的每个节点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC。

#### 如何基于链表实现LRU缓存淘汰算法？

维护一个有序的单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。

1.如果此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2.如果此数据没有在缓存链表中，又可以分为两种情况：
+ 如果此时缓存未满，则将此结点直接插入到链表的头部
+ 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入到链表的头部

#### 如何判断一个字符串是否是回文字符串的

1.快慢指针定位中间结点
2.从中间结点对后半部分逆序
3.前后半部分比较，判断是否为回文
4.后半部分逆序复原

### 如何写出正确的链表代码

1.理解指针或引用的含义

理解指针：将某个变量赋值给指针，实际上就是将变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

```
// p结点的next指针存储了q结点的内存地址
p->next = q

// p结点的next指针存储了p结点的下下一个结点的内存地址
p->next = p->next->next
```

2.警惕指针丢失和内存泄漏

对于有些语言来说，内存管理由程序员负责，如果没有手动释放结点对应的内存空间，就会产生内存泄漏。所以，插入结点时，插入结点的时，一定要注意操作的顺序。删除链表结点的时候，也一定要记得手动释放内存空间。
当然，对于Java这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

3.利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。
`head = null`表示链表中没有结点了。其中`head`表示头节点指针，指向链表中的第一个结点元素。如果引入哨兵结点，在任何时候，不管链表是不是空，`head`指针都会一直指向这个哨兵结点。这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫做不带头链表。

4.重点留意边界条件处理

软件开发中，代码在一些边界或者异常情况下，最容易产生Bug。

经常用来检查链表代码是否正确的边界条件有这样几个：
1.如果链表为空时，代码是否能正常工作？
2.如果链表只包含一个结点时，代码是否能正常工作？
3.如果链表只包含两个结点时，代码是否能正常工作？
4.代码逻辑在处理头结点和为结点的时候，是否能正常工作？

实际上，不光光是写链表代码，在写任何代码的时候，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，代码在运行的时候，可能会遇到哪些边界情况或者异常情况。针对不同的场景，可能还有特定的边界条件。

5.举例画图，辅助思考

6.多写多练，没有捷径

小练习：5个常见的链表操作
1.单链表反转
2.链表中环的检测
3.两个有序的链表合并
4.删除链表倒数第n个结点
5.求链表的中间点

### 栈：如何实现浏览器的前进和后退功能

后进者先出，先进者后出。栈是一种操作受限的线性表，只允许在一端插入和删除数据。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选栈这种数据结构。

实际上，栈既可以用数组来实现，也可以用链表来实现。数组实现的叫作顺序栈，链表实现的叫链式栈。

经典应用场景1：函数调用栈

操作系统给每个线程分配了一个块独立的内存空间，这块内存被组织成栈结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

经典应用场景2：表达式求值

编译器就是通过两个栈来实现的。其中一个保存操作树的栈，另一个是保存运算符的栈。从左往右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果如果比运算符栈顶元素的优先级搞，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

经典应用场景3：括号匹配

假设表达式中只包含三种括号：圆括号()、方括号[]和或括号{}，并且他们可以任意嵌套。如何检查合法哪？

用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，未非法格式。

### 队列：队列在线程池等有限资源池中的应用

CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

队列特点：先进者先出。
基本操作：
1.入队，放一个数据到队列尾部
2.出队，从队列头部取一个元素

与栈一样，也是一种操作受限的线性表数据结构。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

写好队列的关键是确定好队空和队满的判定条件

循环队列队满情况判断:(tail + 1)%n = head

#### 阻塞队列和并发队列

阻塞队列是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞，因为没有数据可取，直到队列中有了数据才能返回。如果队列已经满了，那么插入数据的操作就会被阻塞，知道队列中有空闲位置后再插入数据，然后再返回。

并发队列也叫线程安全队列。最简单的实现方式就是直接再enqueue()、dequeue()、方法上加锁，但是锁粒度大并发会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。

#### 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的？

两种处理策略：

1.非阻塞的处理方式，直接拒绝任务请求
2.阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。

基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。

基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。

实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过队列这种数据结构来实现请求排队。

### 递归：如何用三行代码找到“最终推荐人”？

#### 递归需要满足的三个条件

1.一个问题的解可以分解为几个子问题的解
2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3.存在递归终止条件

#### 如何编写递归代码？

写出递推公式，找到终止条件

写递归代码的关键就时找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易绕进去。

编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。

注意事项：
1.递归代码警惕堆栈溢出
2.递归代码警惕重复计算

递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时比较多等问题。

### 排序（上）：为什么插入排序比冒泡排序更受欢迎？

同一阶时间复杂度的排序算法性能对比的时候，