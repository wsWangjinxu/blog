<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【leetcode刷题笔记】1.二分查找的变种</title>
      <link href="/2020/04/11/%E3%80%90leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8F%98%E7%A7%8D/"/>
      <url>/2020/04/11/%E3%80%90leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8F%98%E7%A7%8D/</url>
      
        <content type="html"><![CDATA[<p>二分查找是一个非常经典的查找算法。需要特别注意的点是要查找的内容一定是要线性存储，而且必须是有序的。下面是两道二分查找的变种题目：</p><ul><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></li></ul><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>实现思路：这道题的数据非常有特点，数据在某个特定范围是有序的。中间有一个高点，比右边紧挨着的一个元素大。所以可以找到这个点，在左右两边分别进行二分查找。<br>找点的关键是要分清楚到底是在左边坡，还是在右边坡。<br>下面是代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只有一个元素</span></span><br><span class="line">  <span class="keyword">if</span>(nums[<span class="number">0</span>] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> point = findPoint(left, right, nums)</span><br><span class="line">  <span class="comment">// 在旋转点左侧查找</span></span><br><span class="line">  <span class="keyword">let</span> leftRes = binarySearch(<span class="number">0</span>, point, nums, target)</span><br><span class="line">  <span class="comment">// 在旋转点右侧查找</span></span><br><span class="line">  <span class="keyword">let</span> rightRes = binarySearch(point + <span class="number">1</span>, nums.length - <span class="number">1</span>, nums, target)</span><br><span class="line">  <span class="keyword">return</span> leftRes === <span class="number">-1</span> ? rightRes : leftRes</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">left, right, nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPoint</span>(<span class="params">left, right, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] &lt; nums[right]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((left + right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在右坡</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[left] ) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在左坡</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p>实现思路：这道题目中要查找的target可能有多个，要想找到两边的初始值，需要在二分点，继续向左或者向右递归查找，如果没有找到，就分别将左、右端点的值返回，作为最靠近两端的值。<br>下面是代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> mid </span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="comment">// 第一次找到一个值</span></span><br><span class="line">    <span class="keyword">let</span> firstSearch = search(left, right, nums, target)</span><br><span class="line">    <span class="keyword">if</span>(firstSearch === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有找到值</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="comment">// 尽可能向右找</span></span><br><span class="line">        <span class="keyword">let</span> resRight = search(firstSearch, right, nums, target, firstSearch - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 尽可能向左找</span></span><br><span class="line">        <span class="keyword">let</span> resLeft = search(left, firstSearch - <span class="number">2</span>, nums, target, firstSearch - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> [resLeft <span class="number">-1</span>, resRight - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">left, right, nums, target, preResult</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] === target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(preResult &lt; mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> search(mid + <span class="number">1</span>, right, nums, target, mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> search(left, mid - <span class="number">1</span>, nums, target, mid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preResult + <span class="number">1</span> || <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS手写代码系列</title>
      <link href="/2020/04/10/JS%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
      <url>/2020/04/10/JS%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>以下这些代码，单单是靠死记硬背是靠不住的。需要结合知识点，理解到底是怎么实现的。欢迎大家点赞，关注，相互学习，一起进步！</p><ul><li><a href="#手写一个new">手写一个new</a></li><li><a href="#手写一个call、apply">手写一个call、apply</a></li><li><a href="#手写一个bind">手写一个bind</a></li><li><a href="#手写一个instanceof">手写一个instanceof</a></li><li><a href="#手写一个ajax">手写一个ajax</a></li><li><a href="#手写一个继承">手写一个继承</a></li><li><a href="#手写一个函数柯里化currying">手写一个函数柯里化</a></li><li><a href="#手写一个节流throttle">手写一个节流</a></li><li><a href="#手写一个防抖debounce">手写一个防抖</a></li><li><a href="#手写一个深拷贝">手写一个深拷贝</a></li><li><a href="#手写一个数组扁平化">手写一个数组扁平化</a></li><li><a href="#手写一个promise">手写一个promise</a></li></ul><h2 id="手写一个new"><a href="#手写一个new" class="headerlink" title="手写一个new"></a>手写一个new</h2><p><code>new</code>操作符做了哪些事情？</p><ul><li>创建一个新的对象</li><li>新对象会被执行<code>[[Prototype]]</code>连接，关联到构造函数的<code>.prototype</code>对象上</li><li>新对象会绑定到函数调用的<code>this</code></li><li>如果函数没有返回其他对象，那么<code>new</code>表达式中的函数会调用自动返回这个新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'func is not a constructor'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(obj, func.prototype)</span><br><span class="line">    <span class="keyword">let</span> tempObj = func.apply(obj, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tempObj === <span class="string">'object'</span> || (<span class="keyword">typeof</span> tempObj === <span class="string">'function'</span> &amp;&amp; tempObj !== <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> tempObj</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个call、apply"><a href="#手写一个call、apply" class="headerlink" title="手写一个call、apply"></a>手写一个call、apply</h2><p><code>Function.prototype.call</code>是如何工作的哪？实现原理是怎样的？</p><ul><li>指定调用时的第一个参数为<code>this</code>指向的对象</li><li>如果传入一个原始值来当作<code>this</code>的绑定对象，这个原始值会被“装箱转换”成包装对象。</li><li>实现原理是利用隐式绑定时<code>this</code>指向调用函数的上下文来将<code>this</code>转移到指定的对象上</li></ul><p><code>Function.ptototype.apply</code>与<code>Function.prototype.call</code>类似，只是前者接收参数数组，后者接收参数列表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mockCall = <span class="function"><span class="keyword">function</span>(<span class="params">contextObj = window, ...args</span>) </span>&#123;</span><br><span class="line">    contextObj = <span class="built_in">Object</span>(contextObj)</span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">    contextObj[key] = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> result = contextObj[key](...args)</span><br><span class="line">    <span class="keyword">delete</span> contextObj[key]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mockApply = <span class="function"><span class="keyword">function</span>(<span class="params">contextObj = window, args</span>) </span>&#123;</span><br><span class="line">    contextObj = <span class="keyword">new</span> <span class="built_in">Object</span>(contextObj)</span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">    contextObj[key] = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> result = args.length ? contextObj[key](args) : contextObj[key]()</span><br><span class="line">    <span class="keyword">delete</span> contextObj[key]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个bind"><a href="#手写一个bind" class="headerlink" title="手写一个bind"></a>手写一个bind</h2><p><code>Function.prototype.bind</code>方法创建一个新的函数，在被调用的时候，这个新的函数的<code>this</code>被指定为<code>bind()</code>的第一个参数，而其余的参数将作为新函数的初始参数，供调用时使用。</p><p>实现思路：</p><ul><li>利用闭包保存调用<code>bind</code>时的<code>this</code>，这时的<code>this</code>就是原函数</li><li>使用<code>call/apply</code>指定<code>this</code></li><li>返回一个绑定函数</li><li>当返回的绑定函数被<code>new</code>运算符调用的时候，绑定的上下文指向<code>new</code>运算符创建的对象</li><li>将绑定函数的<code>prototype</code>修改为原函数的<code>prototype</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mockBind = <span class="function"><span class="keyword">function</span>(<span class="params">contextObj, ...initArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="keyword">this</span> <span class="keyword">instanceof</span> bindFn ? <span class="keyword">this</span> : contextObj, ...initArgs, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">    bindFn.prototype = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">    <span class="keyword">return</span> bindfn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个instanceof"><a href="#手写一个instanceof" class="headerlink" title="手写一个instanceof"></a>手写一个instanceof</h2><p><code>instanceof</code>运算符用来检测构造函数的<code>prototype</code>属性是否出现在左侧实例对象的原型链上，是就返回<code>true</code>，否则返回<code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockInstanceof</span>(<span class="params">obj, constructorFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = obj.__proto__</span><br><span class="line">    <span class="keyword">let</span> prototype = constructorFunc.prototype</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个ajax"><a href="#手写一个ajax" class="headerlink" title="手写一个ajax"></a>手写一个ajax</h2><p>readyState的几个状态：</p><ul><li>0 （未初始化）还没有调用 send 方法</li><li>1 （载入）已调用 send 方法，正在发送请求</li><li>2 （载入完成）send 方法执行完成，已经接收到全部响应内容</li><li>3 （交互）正在解析响应内容</li><li>4 （完成）响应内容解析完成，可以在客户端调用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/data/test.json'</span>, <span class="literal">true</span>) <span class="comment">// true 表示异步，false 表示同步</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postData = &#123;</span><br><span class="line">    username: <span class="string">'zhangsan'</span>,</span><br><span class="line">    password: <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(postData))</span><br></pre></td></tr></table></figure><h2 id="手写一个节流throttle"><a href="#手写一个节流throttle" class="headerlink" title="手写一个节流throttle"></a>手写一个节流throttle</h2><p>在一些需要高频触发事件的地方，可以使用节流来做性能优化。一般来说窗口的滚动事件，鼠标的移动，在不进行节流的情况下是非常耗费性能的。使用节流可以让事件以一定的频率触发（减少事件触发的频率），从而达到在满足需求的情况下提升性能的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个防抖debounce"><a href="#手写一个防抖debounce" class="headerlink" title="手写一个防抖debounce"></a>手写一个防抖debounce</h2><p>用户多次点击一个按钮，使用防抖的话，仅仅会在最后一次触发——一个典型的性能优化场景。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个继承"><a href="#手写一个继承" class="headerlink" title="手写一个继承"></a>手写一个继承</h2><p>经典的寄生组合式继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"say"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Dog.prototype, Animal.prototype)</span><br></pre></td></tr></table></figure><h2 id="手写一个函数柯里化currying"><a href="#手写一个函数柯里化currying" class="headerlink" title="手写一个函数柯里化currying"></a>手写一个函数柯里化currying</h2><p>所谓的柯里化函数，就是封装一系列的处理步骤，通过闭包将参数集中起来计算，最后再把需要处理的参数传进去。</p><p>实现原理：用闭包把传入的参数保存起来，当出入参数的数量足够执行函数时，就开始执行函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, length</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.length &gt;= length ?</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args):</span><br><span class="line">      currying(fn.bind(<span class="keyword">this</span>, ...args), length - args.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个深拷贝"><a href="#手写一个深拷贝" class="headerlink" title="手写一个深拷贝"></a>手写一个深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="comment">// obj 是 null，或者不是对象和数组，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 保证 key 不是原型或原型链的数据</span></span><br><span class="line">            result[key] = deepClone(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个数组扁平化"><a href="#手写一个数组扁平化" class="headerlink" title="手写一个数组扁平化"></a>手写一个数组扁平化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 验证 arr 中，还有没有深层数组</span></span><br><span class="line">    <span class="keyword">const</span> isDeep = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br><span class="line">    <span class="keyword">if</span>(isDeep) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>.prototype.concat.apply([], arr)</span><br><span class="line">    <span class="keyword">return</span> flat(arr) <span class="comment">// 递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个promise"><a href="#手写一个promise" class="headerlink" title="手写一个promise"></a>手写一个promise</h2><p>流程：</p><ul><li>实现 promise 的基本框架</li><li>增加状态机</li><li>实现 then 方法</li><li>实现异步调用</li><li>实现 then 的链式调用</li><li>实现 catch 的异常处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVE = <span class="string">'RESOLVE'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    <span class="comment">// .then handler queue</span></span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line"></span><br><span class="line">    doResolve(<span class="keyword">this</span>, executor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onResolved, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> APromise(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">// store the promise as well</span></span><br><span class="line">    handle(<span class="keyword">this</span>, &#123; promise, onResolved, onRejected &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(func) &#123;</span><br><span class="line">    <span class="keyword">this</span>.then.call(<span class="keyword">this</span>, <span class="literal">null</span>, func)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现 Promise.all</span></span><br><span class="line">  <span class="keyword">static</span> all(arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">fulfill, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i].then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          result[i] = res</span><br><span class="line">          <span class="keyword">if</span> (result.length === arr.length) &#123;</span><br><span class="line">            fulfill(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, rejected)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现 Promise.race</span></span><br><span class="line">  <span class="keyword">static</span> race(arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">fulfill, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i].then(fulfill, rejected)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">promise, value</span>) </span>&#123;</span><br><span class="line">  promise.state = RESOLVE</span><br><span class="line">  promise.value = value</span><br><span class="line">  finale(promise)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">  promise.state = REJECTED</span><br><span class="line">  promise.value = reason</span><br><span class="line">  finale(promise)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span>(<span class="params">promise, executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrapResolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">    resolve(promise, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrapReject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">    reject(promise, reason)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(wrapResolve, wrapReject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    wrapReject(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 promise 的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">promise, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (promise.value <span class="keyword">instanceof</span> APromise) &#123;</span><br><span class="line">    promise = promise.value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (promise.state === PENDING) &#123;</span><br><span class="line">    <span class="comment">// 等待状态入队</span></span><br><span class="line">    promise.queue.push(handler)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 立即执行</span></span><br><span class="line">    handleResolved(promise, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用所有的handler</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = promise.queue.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    handle(promise, promise.queue[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResolved</span>(<span class="params">promise, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cb = promise.state === RESOLVE ? handler.onResolved : handler.onRejected</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = cb(promise.value)</span><br><span class="line">    resolve(handler.promise, value)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    reject(handler.promise, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gitflow学习笔记</title>
      <link href="/2020/04/07/Gitflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/07/Gitflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>2010年的时候Vincent Driessen曾经写过一篇题目为<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">”A successful Git branching model”</a>的文章，gitflow 的工作流程就是从这里来的。gitflow遵循严格的分支管理模型。对于我们平时开发分支的管理很有借鉴意义。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。</p><h2 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h2><ul><li>master<br>  master 分支都是可以直接发布的稳定版本，每次版本发布都会在 master 上打标签，也就是说master分支上的代码都是可以直接发布的稳定版本</li><li>develop<br>  develop 分支保存所有的版本历史，往往代码也是最新的</li><li>feature（临时分支）<br>  当有新的需求要开发新的功能的时候，就从develop分支迁出一个新的feature分支开发新的功能。当功能开发完成以后可以将feature分支合并回develop分支，此时可以进行code review和代码评审。完成这些以后可以合并到develop并删除feature分支</li><li>release（临时分支）<br>  这里是预发布的版本，当从develop分支迁出一个准备发布的版本，主要用于文档整理，功能测试 。完善以后可以发布到master分支，并用版本号打上标签，同时需要再合并到develop分支。完成上述操作以后可以将release分支删除。</li><li>hotfix（临时分支）<br>  这是用来修复bug的分支。当线上master分支遇到bug需要修复的时候，可以从master分支迁出hotfix分支修复。修复完成以后合并回master分支和develop分支。此时的develop分支还在继续迭代中。修复的bug会在下次发布的时候被修复。</li></ul><h2 id="用故事来举个栗子"><a href="#用故事来举个栗子" class="headerlink" title="用故事来举个栗子"></a>用故事来举个栗子</h2><p>小何和小刘是公司前端的得力干将。当前有个项目已经用脚手架搭建完成，并且自动生成了默认的master分支。</p><h3 id="迁出develop分支"><a href="#迁出develop分支" class="headerlink" title="迁出develop分支"></a>迁出develop分支</h3><p>团队商量决定使用gitflow的分支管理方案。于是乎小何一顿操作基于master分支建立了develop分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 develop 分支</span></span><br><span class="line">git checkout -b develop master</span><br><span class="line"><span class="comment"># 推到远程仓库</span></span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure></p><p>这时候develop和master分支的代码都是一样的。程序员做事情那都是说干就干，下面立马开始了新功能的开发。小何和小刘一顿商量，如此如此，这般这般就把任务给分配了。</p><h3 id="在feature分支上开发新的功能"><a href="#在feature分支上开发新的功能" class="headerlink" title="在feature分支上开发新的功能"></a>在feature分支上开发新的功能</h3><p>小刘负责了一个A功能，于是他在命令行里输入了如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建开发 A 功能的分支，以 feature-A 来命名</span></span><br><span class="line">git checkout -b feature-A develop</span><br></pre></td></tr></table></figure></p><p>完事以后，扑到编辑器里一顿操作。于此同时，小何的分支也如法炮制的创建好了。两位老哥不遗余力的耕耘了多少个日夜。<br>虽然新的功能还没有完全开发完，但是分支的代码还是可以保留在远程。这样就不怕自己电脑出问题了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit </span><br><span class="line">git push -u origin feature-A</span><br></pre></td></tr></table></figure></p><p>小刘的A功能开发完事以后，就可以进行code review和代码评审了。评审通过以后就可以合并到develop分支了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 feature-A 分支合并到 develop 分支</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff feature-A</span><br><span class="line"><span class="comment"># 删除 feature-A 分支</span></span><br><span class="line">git branch -d feature-A</span><br></pre></td></tr></table></figure></p><p>没想到这时候公司新来的小胡已经提交了好几个feature（develop分支一直的积累新的功能）了。feature-A分支合并完成以后，小刘依依不舍的删除了自己的分支，回想起无数个寂寞的夜，嘴里还叼着那半根没有抽完的烟……</p><h3 id="准备发布新版本了"><a href="#准备发布新版本了" class="headerlink" title="准备发布新版本了"></a>准备发布新版本了</h3><p>当develop分支的功能积累的差不多的时候了，该发布新版本了，于是乎小刘基于develop分支迁出了一个新的release分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-0.1 develop</span><br></pre></td></tr></table></figure></p><p>这个分支是专门用于发布前的准备，包括一些清理工作、全面的测试、文档的更新以及任何其他的准备工作。它与功能开发的分支相似，不同之处在于是专门为产品发布服务的。准备工作完成以后，就可以合并到master和develop分支了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并到 master 分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff master</span><br><span class="line"><span class="comment"># 对合并生成的新节点，做一个标签</span></span><br><span class="line">git tag -a 0.1</span><br><span class="line"><span class="comment"># 合并到 develop 分支</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-0.1</span><br><span class="line"><span class="comment"># 删除预发布分支</span></span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure></p><p>小刘的A功能终于上线了。</p><h3 id="出Bug了"><a href="#出Bug了" class="headerlink" title="出Bug了"></a>出Bug了</h3><p>虽然经过了严格的测试但是还是出现了bug。可能是功能的逻辑太复杂，也可能是测试用例没有覆盖到。总是是出了bug。小刘开心的笑出了声，原来我平时开发的网站真的有人在用（手动狗头）。打开命令行就是一顿操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迁出一个 hotfix 分支修改 bug</span></span><br><span class="line">git checkout -b hotfix-0.1 master</span><br></pre></td></tr></table></figure></p><p>小刘使出了九牛二虎之力，终于把bug给修复了。露出了欣慰的笑容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将修改的结果合并到 master 上</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff fixbug-0.1</span><br><span class="line"><span class="comment"># 打上标签</span></span><br><span class="line">git tag -a 0.1.1</span><br><span class="line"><span class="comment"># 再合并到 develop 分支上</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff hotfix-0.1</span><br><span class="line"><span class="comment"># 删除 hotfix 分支</span></span><br><span class="line">git branch -d hotfix-0.1</span><br></pre></td></tr></table></figure></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/jeffery-zou/p/10280167.html" target="_blank" rel="noopener">Gitflow 工作流程</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git 分支管理策略</a></li><li><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 PM2 管理你的 node 应用程序</title>
      <link href="/2020/04/04/%E4%BD%BF%E7%94%A8PM2%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84node%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/04/04/%E4%BD%BF%E7%94%A8PM2%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84node%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>PM2 是守护程序进程管理器，主要有三个核心点：进程守护，当系统崩溃的时候能够自动重启；能够启动多进程，充分利用 CPU 和内存；自带日志记录功能。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以通过 npm 和 yarn 安装最新的 pm2 版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn global add pm2</span><br></pre></td></tr></table></figure></p><h2 id="三个核心功能"><a href="#三个核心功能" class="headerlink" title="三个核心功能"></a>三个核心功能</h2><h3 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h3><p>当你使用 <code>node app.js</code>和<code>nodemon app.js</code>启动 node 应用程序的时候，遇到程序出现 bug，进程就会崩溃，这样你的服务器就会宕机。在 pm2 中使用<code>pm2 start app.js</code>这种最简单的方式启动你的node 应用。就能够守护和监视你的应用。当程序遇到错误崩溃的时候，系统会自动重启，保证系统没有问题的部分仍然是可用的。</p><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>集群模式允许联网的 node 应用在不用修改代码的情况下，根据可用的 CPU 数量进行缩放。这将大大提高应用程序的性能和可靠性。由于 node 单核可用内存是有限的，使用 pm2 可以在资源允许的情况下启动多个子进程。如果想要这样做，你只需要在配置文件中写入<code>instances: &quot;max&quot;,exec_mode: &quot;cluster&quot;</code>即可。当然，你也可以按个人需求配置对应的实例数量。</p><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>在 pm2 中可以实时显示来自所有应用程序的日志，刷新并重新加载它们。你还通过编写配置文件的形式将日志保存并分隔在不同的文件中，这些操作你都不需要修改代码中的任何内容。如果你需要实时显示日志，可以在命令行中输入<code>pm2 logs &lt;AppName&gt;</code>。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在文件更改时自动重启应用</span></span><br><span class="line">pm2 start app.js --watch</span><br><span class="line"><span class="comment"># 管理应用程序状态</span></span><br><span class="line">pm2 restart app_name</span><br><span class="line">pm2 reload app_name</span><br><span class="line">pm2 stop app_name</span><br><span class="line">pm2 delete app_name</span><br><span class="line"><span class="comment"># 列出托管的应用程序</span></span><br><span class="line">pm2 ls </span><br><span class="line"><span class="comment"># 显示日志 </span></span><br><span class="line">pm2 logs</span><br><span class="line"><span class="comment"># 显示基于终端的实时仪表板</span></span><br><span class="line">pm2 monit</span><br></pre></td></tr></table></figure><h2 id="ecosystem-文件"><a href="#ecosystem-文件" class="headerlink" title="ecosystem 文件"></a>ecosystem 文件</h2><p>以上只是关于 pm2 入门的概述和一些日常使用命令的介绍，想要获得更多的功能可以使用ecosystem 配置文件，生成配置文件的命令是<code>pm2 ecosystem</code>，配置文件的详细配置项可以参考<a href="https://pm2.keymetrics.io/docs/usage/application-declaration/" target="_blank" rel="noopener">这里</a>。这是只是做一个简单的概述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pm2 的<a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">文档</a>写的非常详细，而且还有很多很多功能，最重要的是上手还很容易，如果你不幸看到了我写的这么简陋的文章，请帮忙点个赞，激励我写出更多高质量的文章来，写文章不易，你看我已经很久没写了，今天好不容易又提起兴趣来了（手动狗头）。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>我能说我基本都是照抄<a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">官网</a>的吗？什么？你不想看英文？…</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用页面尺寸与位置的获取</title>
      <link href="/2019/10/20/%E5%B8%B8%E7%94%A8%E9%A1%B5%E9%9D%A2%E5%B0%BA%E5%AF%B8%E4%B8%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
      <url>/2019/10/20/%E5%B8%B8%E7%94%A8%E9%A1%B5%E9%9D%A2%E5%B0%BA%E5%AF%B8%E4%B8%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>最近开发中使用了一个电商放大镜组件，遇到了这方面的问题。日常开发中，也经常会获取一个元素的尺寸与位置，借此机会，总结下来。</p><h2 id="常见的尺寸与位置分类"><a href="#常见的尺寸与位置分类" class="headerlink" title="常见的尺寸与位置分类"></a>常见的尺寸与位置分类</h2><p>在 web 页面开发中，尺寸和位置大致分为以下几类：</p><ul><li>屏幕的尺寸和位置</li><li>元素尺寸和位置（文档，算是一个特殊的元素）</li><li>鼠标的位置</li></ul><h3 id="屏幕的尺寸和位置"><a href="#屏幕的尺寸和位置" class="headerlink" title="屏幕的尺寸和位置"></a>屏幕的尺寸和位置</h3><p>其中屏幕的尺寸和位置是通过<code>window.screen</code>对象来获取的，这里包含我们设备屏幕的一些信息，其中与尺寸和位置有关的如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen.width <span class="comment">// 屏幕的像素宽度</span></span><br><span class="line">screen.height <span class="comment">// 屏幕的像素高度</span></span><br><span class="line">screen.availHeight <span class="comment">// 返回浏览器窗口在屏幕上可占用的垂直空间，即最大高度</span></span><br><span class="line">screen.availWidth <span class="comment">// 返回浏览器窗口可占用的水平宽度（单位：像素）</span></span><br><span class="line">screen.availLeft <span class="comment">// 返回浏览器可用空间左边距离屏幕（系统桌面）左边界的距离</span></span><br><span class="line">screen.availTop <span class="comment">// 浏览器窗口在屏幕上的可占用空间上边距离屏幕上边界的像素值，在 mac 上就是任务栏的高度</span></span><br></pre></td></tr></table></figure><p>需要说明的是可占用宽度和高度，并<strong>不是实际占用的宽度和高度</strong>，如果你缩小的浏览器的窗口，这两个值依然不会更改。对于<code>availLeft</code>来说，大多数情况下，该属性返回都是 0，如果你在有两个屏幕的电脑上使用该属性，在右侧屏幕计算该属性时，会返回左侧屏幕的宽度。在 windows 中，该属性取决于哪个屏幕被设为主屏幕，返回相对于主屏幕左边界的 X 坐标。</p><h3 id="元素的尺寸和位置"><a href="#元素的尺寸和位置" class="headerlink" title="元素的尺寸和位置"></a>元素的尺寸和位置</h3><p>元素的尺寸与盒子模型和 CSS有关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">element.clientWidth </span><br><span class="line">element.clientHeight</span><br><span class="line"><span class="comment">// 以上两个属性都是只读属性，对于没有定义 CSS 或者 内联布局盒子的元素为 0，否则，他是元素内部的宽高，</span></span><br><span class="line"><span class="comment">// 包含 padding，但不包括滚动条、边框和外边框。</span></span><br><span class="line"></span><br><span class="line">element.offsetWidth</span><br><span class="line">element.offsetHeight</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两个属性都是只读属性，它返回该元素的像素宽高，包含该元素的垂直内边距和边框，且是一个整数。</span></span><br><span class="line"><span class="comment">// 通常，元素的offsetHeight是一种元素 CSS 宽高的衡量标准，包括元素的 border、</span></span><br><span class="line"><span class="comment">// padding 和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度</span></span><br><span class="line"></span><br><span class="line">element.scrollWidth</span><br><span class="line">element.scrollHeight</span><br><span class="line"><span class="comment">// 以上两个只读属性是元素内容宽度的一种度量，包括由于 overflow 溢出而在屏幕上不可见的内容。</span></span><br><span class="line"><span class="comment">// 上面的宽高等于元素在不使用滚动条的情况下为了适用视口中所用内容所需的最小高度。</span></span><br><span class="line"><span class="comment">// 在没有滚动条的情况下与 clientHeight 和 clientWidth 相同</span></span><br></pre></td></tr></table></figure><p>与元素的位置相关属性都是相对位置，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素的尺寸</span></span><br><span class="line">element.offsetParent <span class="comment">// 获取偏移容器</span></span><br><span class="line">element.offsetLeft; <span class="comment">// 元素相对与偏移容器的左边的偏移量</span></span><br><span class="line">element.offsetTop; <span class="comment">// 元素相对于偏移容器的顶边的偏移量</span></span><br><span class="line">  </span><br><span class="line">element.clientLeft; <span class="comment">// 通常情况下是元素盒子的左边框的宽度</span></span><br><span class="line">eelementle.clientTop; <span class="comment">// 通常情况下是元素盒子的顶边框的宽度</span></span><br><span class="line">  </span><br><span class="line">element.scrollLeft; <span class="comment">// 横向滚动条相对于滚动区域宽度(scrollWidth)的位置【滚动条的位置】</span></span><br><span class="line">element.scrollTop; <span class="comment">//纵向滚动条相对于滚动区域高度(scrollHeight)的位置【滚动条的位置】</span></span><br><span class="line"></span><br><span class="line">element.scrollLeft = <span class="number">30</span>; <span class="comment">//设置内容区域滚动到30的位置</span></span><br><span class="line">element.scrollTop = <span class="number">50</span>; <span class="comment">//设置内容区域滚动到50的位置</span></span><br></pre></td></tr></table></figure></p><h4 id="特殊元素——页面尺寸与位置的获取"><a href="#特殊元素——页面尺寸与位置的获取" class="headerlink" title="特殊元素——页面尺寸与位置的获取"></a>特殊元素——页面尺寸与位置的获取</h4><p>特殊的元素<code>html</code>或者是<code>body</code>，都可以用来获取页面的尺寸与位置（使用 CSS Reset 去掉<code>body</code>的默认<code>margin</code>后，<code>body</code>与<code>html</code>重合），也包含上述的几种属性，只是这两个元素的<code>offsetParent</code>都是<code>null</code>。通过设置<code>scrollTop</code>或者<code>scrollWidth</code>可以让页面滚动到具体的位置。下面是通常用来获取这两个元素的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement <span class="comment">// 获取 html</span></span><br><span class="line"><span class="built_in">document</span>.body <span class="comment">// 获取 body</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助 html 获取 viewport 的大小，要获取 html 的大小可以使用 offsetHeight 和 offsetWidth</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure><h3 id="获取鼠标的位置"><a href="#获取鼠标的位置" class="headerlink" title="获取鼠标的位置"></a>获取鼠标的位置</h3><p>鼠标的位置是从鼠标事件中获取的，在事件发生的时候，<code>event</code>对象中有一些属性与鼠标的位置相关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.addEventListener(<span class="string">"click"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"相对于浏览器客户区的位置X:"</span>,event.clientX);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"相对于浏览器客户区的位置Y:"</span>,event.clientY);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"相对于页面的位置X:"</span>,event.clientX);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"相对于页面的位置Y:"</span>,event.clientY);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"相对于主屏幕的位置X:"</span>,event.screenX);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"相对于主屏幕的位置Y:"</span>,event.screenY);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>clientX</code>、<code>clientY</code>是鼠标相对于浏览器客户区的位置，不包括浏览器的地址栏，书签栏，底部状态栏等浏览器特性，只是文档显示区域。永远为正值。</p><p><code>pageX</code>、<code>pageY</code>是鼠标相对于文档的位置，即相对于document的位置。<code>pageX</code>、<code>pageY</code>和<code>clientX</code>、<code>clientY</code>和<code>body</code>的宽度无关。如果页面没有滚动的话，二者的值相等。永远为正值。</p><p><code>screenX</code>、<code>screenY</code>是鼠标相对于主屏幕的位置。存在负值，这就要看扩展屏幕的设置了。</p><h2 id="快速获取元素的绝对位置与相对位置"><a href="#快速获取元素的绝对位置与相对位置" class="headerlink" title="快速获取元素的绝对位置与相对位置"></a>快速获取元素的绝对位置与相对位置</h2><p>说到元素的绝对与相对位置都是相对于元素的左上角来说的。绝对位置就是相对于整个 html 文档的左上角的位置；相对位置就是相对于整个视口的左上角。</p><p><code>getBoundingClientRect</code>方法返回值是一个 DOMRect 对象，这个对象描述的是与该元素相关的CSS 边框集合。其中有<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>四个属性表示相对于视口的坐上角的位置，这四个属性就可以<strong>直接获取元素的相对位置</strong>。在发生滚动的时候，<code>top</code>和<code>left</code>属性值就会随之发生变化。因此，<strong>在不发生滚动的情况下，他们就是即是元素的相对位置也是元素的绝对位置</strong>。</p><p>如果要<strong>计算元素的滚动元素的绝对位置，我们只需要用该元素的相对位置加上文档的滚动值</strong>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = docuemnt.getElementById(<span class="string">"my-element"</span>); <span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">let</span> domRect = element.getBoundingClientRect(); <span class="comment">// 获取 DOMRect 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取相对位置</span></span><br><span class="line"><span class="keyword">let</span> elementX = domRect.left;</span><br><span class="line"><span class="keyword">let</span> elementY = domRect.top;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取绝对位置</span></span><br><span class="line"><span class="keyword">let</span> X = elementX + <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line"><span class="keyword">let</span> Y = elementY + <span class="built_in">document</span>.documentElement.scrollTop;</span><br></pre></td></tr></table></figure><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li><a href="https://www.cnblogs.com/pelli/p/6100420.html" target="_blank" rel="noopener">web前端开发中常用的尺寸和位置</a></li><li><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener">用Javascript获取页面元素的位置</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webAPI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闭包的概念与应用</title>
      <link href="/2019/10/07/%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2019/10/07/%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>作为一个 JavaScript 语言的开发者，提起闭包肯定不会感到陌生，那么到底什么才是闭包哪？</p><p>闭包不是什么新奇的概念，它早在高级语言开始发展的年代就产生了。闭包（Closure）是词法闭包的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：</p><ul><li>一种说法认为闭包是<strong>符合一定条件的函数</strong>。认为闭包是在其词法上下文中引用了自由变量（自由变量是指局部变量以外的变量）的函数。</li><li>另一种说法认为闭包是函数和与其相关的引用环境组合而成的实体。认为闭包是<strong>在实现深约束时，需要创建一个能显示表示引用环境的东西</strong>，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。</li></ul><p>这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。很明显第二种说法更确切一些，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。</p><h2 id="JavaScript-闭包的本质"><a href="#JavaScript-闭包的本质" class="headerlink" title="JavaScript 闭包的本质"></a>JavaScript 闭包的本质</h2><p>在支持嵌套作用域的语言中，有时不能简单直接的确定函数的引用环境。这样的语言一般具有这样的特性：</p><ul><li>函数是一等公民，即函数可以作为一个函数的返回值或参数，还可以作为一个变量的值</li><li>函数可以嵌套定义，即在一个函数内部可以定义另一个函数。</li></ul><p>JavaScript 闭包的源自两点，<strong>词法作用域和函数当做值传递</strong>。</p><p>作用域是查找变量时的一些规则。词法作用域就是定义在词法阶段的作用域。或者换句话说，词法作用域是由你书写代码时将变量和块作用域写在哪里来决定的。按照代码书写时的样子，内部函数可以顺着作用域链一层一层地查找、访问函数外的变量，或者我们叫它自由变量。</p><p>函数当做值传递，也就是上面所说的函数是一等公民。函数内部的自由变量是在外层函数执行时创建的，外层函数执行完以后，这些变量理应被销毁，但是如果将内层函数作为返回值返回，这些自由变量就被保存了下来。而且无法访问，必须通过内层函数来访问。本来执行过程和词法作用域是封闭的，将内层函数作为返回值返回就提供了一种访问自由变量的方式。</p><p>一个函数如何能封闭外部状态哪？<strong>当外部状态的scope失效的时候，还有一份留在内部状态里面</strong>。在执行过程中，返回函数，或者将函数得以保留下来，并且函数中有自由变量就会形成闭包。<strong>一个函数中没有自由变量时，引用环境不会发生变化</strong>。</p><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>知道了什么是闭包，也理解了闭包的本质，下面可以了解下闭包的几种应用，或许你在日常的开发中已经用到不少了。</p><h3 id="封装私有变量，存储计算的值"><a href="#封装私有变量，存储计算的值" class="headerlink" title="封装私有变量，存储计算的值"></a>封装私有变量，存储计算的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将计算的结果保存在 sum 中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = init;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    sum += number;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = init;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当参数到达一定的数量时再进行运算</span></span><br><span class="line">    args = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">if</span>(args.length &gt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum += args[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延续局部变量的寿命"><a href="#延续局部变量的寿命" class="headerlink" title="延续局部变量的寿命"></a>延续局部变量的寿命</h3><p>img 对象经常用于进行数据上报，但是通过查询后台的记录可以得知，因为一些低版本的浏览器的实现可能存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方法会丢失 30% 左右的数据</span></span><br><span class="line"><span class="keyword">var</span> report = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.src = src;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 img 变量封装起来，就可以解决请求丢失的问题</span></span><br><span class="line"><span class="keyword">var</span> report = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgs = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    imgs.push(img);</span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="私有数据和应用程序接口"><a href="#私有数据和应用程序接口" class="headerlink" title="私有数据和应用程序接口"></a>私有数据和应用程序接口</h3><p>有时，你想强制程序与数据的交互方式，以便保护其完整性。通过是使用闭包，完全可以做到这一点。创建此类接口的一种常见方法就是从函数返回对象。这时，定义在原函数中的数据只能由返回对象上定义的方法访问，下面是一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCalendar</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> calendar = &#123;</span><br><span class="line">    owner: name,</span><br><span class="line">    events: [],</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event, dateString</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> eventInfo = &#123;</span><br><span class="line">        event: event,</span><br><span class="line">        date: <span class="keyword">new</span> <span class="built_in">Date</span>(dateString),</span><br><span class="line">      &#125;;</span><br><span class="line">      calendar.events.push(eventInfo);</span><br><span class="line">      calendar.events.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.date - b.date;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    listEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (calendar.events.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(calendar.owner + <span class="string">"'s events are: "</span>);</span><br><span class="line">        </span><br><span class="line">        calendar.events.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">eventInfo</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> dateStr = eventInfo.date.toLocaleDateString();</span><br><span class="line">          <span class="keyword">var</span> description = dateStr + <span class="string">": "</span> + eventInfo.event;</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">console</span>.log(description);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(calendar.owner + <span class="string">" has no events."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h2><p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就会一直存在。在这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量的时候，可以手动把这些变量设置为 null。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#artrelatedtopics" target="_blank" rel="noopener">闭包的概念、形式与应用</a></li><li><a href="https://www.zhihu.com/question/34210214" target="_blank" rel="noopener">什么是闭包？</a></li><li><a href="https://medium.com/launch-school/javascript-weekly-making-sense-of-closures-daa2e0b56f88" target="_blank" rel="noopener">JavaScript Weekly: Making Sense of Closures</a></li><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript 设计模式与开发实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈前端路由</title>
      <link href="/2019/09/19/%E8%B0%88%E8%B0%88%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/09/19/%E8%B0%88%E8%B0%88%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单页面应用与前端路由"><a href="#一、单页面应用与前端路由" class="headerlink" title="一、单页面应用与前端路由"></a>一、单页面应用与前端路由</h2><p>在传统的 Web 开发中，浏览器根据地址栏的 URL 向服务器发送一个 HTTP 请求，服务器根据 URL 返回一个 HTML 页面。这种情况下，一个 URL 对应一个 HTML 页面，<br>一个 Web 应用包含很多 HTML 页面，这样的应用就是多页面应用；在多页面应用中，<strong>页面路由的控制由服务器负责</strong>，这种路由方式称为后端路由。</p><p>在多页面应用中，每次页面切换都需要向服务器发送一次请求，页面使用的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面<br>间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致公共部分的刷新。</p><p>有没有一种方式让 Web 应用只是看起来像多页面应用，也就是说 URL 的变化可以引起页面内容的变化，但不会向服务器发送新的请求哪？满足这种条件的 Web 应用就是单页面<br>应用（Single Page Application，简称 SPA）。单页面应用虽然名为”单页“，但视觉上的感受仍然是多页面，因为 URL 发生变化，页面上的内容也会变化，但这只是逻辑上的多页面，实际上无论 URL 如何变化，对应的 HTML 文件都是同一个，这也是单页面应用名字的由来。在单页面应用中，<strong>URL 发生变化并不会向服务器发送新的请求</strong>，所以”逻辑页面“的变化只能由前端负责，这种方式称为前端路由。</p><h2 id="二、前端路由的实现"><a href="#二、前端路由的实现" class="headerlink" title="二、前端路由的实现"></a>二、前端路由的实现</h2><p><strong>路由就是 URL 到函数的映射</strong>，这个是前端路由的原理。如果做到在 URL 发生变化的时候不向服务器发送请求，而是去执行一个控制 UI 组件的函数哪？那就不得不说说 hash 和 history 这两种实现方案了。</p><h3 id="2-1-基于-hash"><a href="#2-1-基于-hash" class="headerlink" title="2.1 基于 hash"></a>2.1 基于 hash</h3><p>在一个 URL 的组成中，<code>#</code>号包括<code>#</code>号后边的部分称为 hash。在浏览器中，可以通过<code>location.hash</code>获取到。<code>#</code>代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// #title 是 hash</span><br><span class="line">http://www.example.com/index.html#title</span><br></pre></td></tr></table></figure><p><code>#</code>号是用来指导浏览器动作的，对服务器完全不起作用，HTTP 请求不会带上<code>#</code>号以及它后边的内容。单单改变<code>#</code>号后边的内容，浏览器只会滚动到指定的位置，不会重新加载网页。而且改变 hash 还会改变浏览器的历史记录。我们可以通过<code>onhashchange</code>监听到 hash 的改变来不刷新浏览器触发视图的更新。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>white<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#yellow"</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#green"</span>&gt;</span>green<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">这是页面的内容</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.routes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.currentUrl = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Router.prototype.route = <span class="function"><span class="keyword">function</span>(<span class="params">path, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.routes[path] =</span><br><span class="line">    callback ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"请为路由绑定处理方法"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Router.prototype.refresh = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"触发一次 hashchange，hash值为"</span>, location.hash);</span><br><span class="line">  <span class="keyword">this</span>.currentUrl = <span class="string">"/"</span> + location.hash.slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 执行当前路由绑定的方法</span></span><br><span class="line">  <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Router.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="built_in">window</span>.Router.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeBgColor</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  content.style.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Router.route(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  changeBgColor(<span class="string">"white"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Router.route(<span class="string">"/yellow"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  changeBgColor(<span class="string">"yellow"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Router.route(<span class="string">"/green"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  changeBgColor(<span class="string">"green"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-基于-history-模式"><a href="#2-2-基于-history-模式" class="headerlink" title="2.2 基于 history 模式"></a>2.2 基于 history 模式</h3><p>在 HTML5 规范中，history新增了一下几个 API：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.pushState();    <span class="comment">// 添加新的状态到历史状态栈</span></span><br><span class="line">history.replaceState(); <span class="comment">// 用新的状态代替当前状态</span></span><br><span class="line">history.state           <span class="comment">// 返回当前状态对象</span></span><br></pre></td></tr></table></figure></p><p>通过上面两个操作状态的 API，也能够做到：<strong>改变 url 的同时，不刷新页面</strong>。所以 history 也具备实现路由控制的潜力。仅仅是改变 url 不刷新页面还不够，还要能够监听到 url 的变化。对于 hash 来说，hash 的改变可以出发 onhashchange 事件，history 并没有这样的事件可以监听。然而，对于一个应用来说，改变一个 url 只有下面三种途径：</p><ul><li>点击浏览器的前进或者后退</li><li>点击 a 标签</li><li>在 JS 代码中直接修改路由</li></ul><p>第 2 种和第 3 种途径可以看成是一种，因为 a 标签的默认事件可以被禁止，进而调用 js 方法。关键是第 1 种，HTML5 规范种新增了一个 onpopstate 事件，通过它便可以监听到前进或者后退的按钮点击。要特别注意的是：<strong>调用<code>history.pushState</code>和<code>history.replaceState</code>并不会触发 onpopstate 事件</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, onLoad)</span><br><span class="line"><span class="comment">// 监听路由变化</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, onPopState)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由视图</span></span><br><span class="line"><span class="keyword">var</span> routerView = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onLoad</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  routerView = <span class="built_in">document</span>.querySelector(<span class="string">'#routeView'</span>)</span><br><span class="line">  onPopState()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span></span><br><span class="line">  <span class="keyword">var</span> linkList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a[href]'</span>)</span><br><span class="line">  linkList.forEach(<span class="function"><span class="params">el</span> =&gt;</span> el.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    history.pushState(<span class="literal">null</span>, <span class="string">''</span>, el.getAttribute(<span class="string">'href'</span>))</span><br><span class="line">    onPopState()</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由变化时，根据路由渲染对应 UI</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onPopState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (location.pathname) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/home'</span>:</span><br><span class="line">      routerView.innerHTML = <span class="string">'Home'</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/about'</span>:</span><br><span class="line">      routerView.innerHTML = <span class="string">'About'</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-3-hash-vs-history"><a href="#2-3-hash-vs-history" class="headerlink" title="2.3 hash vs history"></a>2.3 hash vs history</h3><p>hash 模式下，每个 url 都会带有<code>#</code>号，看起来可能不太友好。但是，hash 模式兼容 IE8 及其以上的浏览器。history 模式使用了 HTML5 里边新的 API，看起来会比较友好。但是，仅仅有前端的参与还是不够的，需要后端进行配置，前端的路由要和后端的路由要匹配起来，在刷新浏览器的时候会给后端发送请求，这个时候后台需要对请求的 url，做一个捕捉，后端不存在的 url，统一返回请求根路径时的前端环境，交由前端路由模块处理。</p><h2 id="三、参考内容"><a href="#三、参考内容" class="headerlink" title="三、参考内容"></a>三、参考内容</h2><ul><li><a href="https://www.cnblogs.com/m2maomao/p/10611983.html" target="_blank" rel="noopener">URL 中的 hash</a></li><li><a href="https://book.douban.com/subject/30210697/" target="_blank" rel="noopener">React 进阶之路</a></li><li><a href="https://github.com/youngwind/blog/issues/109" target="_blank" rel="noopener">单页面应用路由实现原理</a></li><li><a href="https://www.jianshu.com/p/3fcae6a4968f?open_source=weibo_search" target="_blank" rel="noopener">hash 和 history 两种模式的区别</a></li><li><a href="https://github.com/whinc/blog/issues/13" target="_blank" rel="noopener">前端路由原理解析和实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端路由 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 命令源码文件</title>
      <link href="/2019/05/05/Go%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/"/>
      <url>/2019/05/05/Go%E5%91%BD%E4%BB%A4%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="命令源码文件是什么，怎样编写它？"><a href="#命令源码文件是什么，怎样编写它？" class="headerlink" title="命令源码文件是什么，怎样编写它？"></a>命令源码文件是什么，怎样编写它？</h2><p>如果一个源码文件声明属于 main 包，并且包含一个无参数声明且无结果声明的 main 函数，那就是命令源码文件。</p><p>命令源码文件是程序的入口，通过构建和安装可生成对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 简单的命令源码文件格式</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  fmt.Println(&quot;Hello World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要模块化编程时，会将代码拆分到多个文件，甚至拆分到不同的代码包中。但对于一个独立的程序来说命令源码文件永远只会也只能有一个。如果有与命令源码文件同包的源码文件，也应该声明属于 main 包。</p><h2 id="命令源码文件怎样接收参数"><a href="#命令源码文件怎样接收参数" class="headerlink" title="命令源码文件怎样接收参数"></a>命令源码文件怎样接收参数</h2><p>首先，Go 语言标准库中有一个代码包专门用于接收和解析命令参数，这个代码包的名字叫 flag。可以通过 flag 包的 StringVar 函数来接收命令行参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以接收 go run demo.go -name &quot;wangjinxu&quot; 后面的参数</span><br><span class="line">flag.StringVar(&amp;name, &quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</span><br></pre></td></tr></table></figure><p>函数 flag.StringVar 接受 4 个参数：</p><ul><li>第一个参数是用于存储该命令参数值的地址，具体到上面的例子就是变量 name 的地址，由 <code>&amp;name</code> 表达式表示。</li><li>第二个参数是为了指定该命令的名称，这里是 name。</li><li>第三个参数是为了指定在未追加该命令参数时的默认值，这里是 everyone。</li><li>第四个参数是该命令参数的简短说明。在输入<code>go run file.go --help</code>打印命令说明的时候会出现。</li></ul><p>还有一个与 flag.StringVar 函数类似的函数，叫 flag.String。这两个函数的区别是，后者会直接返回一个已经分配好的用于存储命令参数值的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// name 是存储命令参数值的地址</span><br><span class="line">var name = flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</span><br></pre></td></tr></table></figure><p>接收完参数以后需要解析参数，解析参数需要使用 <code>flag.parse()</code>。对该函数的调用必须在所有命令参数存储载体的生命和设置之后，并且在读取任何命令参数值之前进行，所以需要把 <code>flag.Parse()</code> 放在 main 函数体的第一行。</p><p>下面是完整的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;flag&quot;</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var name string</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">  flag.StringVar(&amp;name, &quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Printf(&quot;Hello, %s\n&quot;, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎样自定义命令源码文件的参数使用说明"><a href="#怎样自定义命令源码文件的参数使用说明" class="headerlink" title="怎样自定义命令源码文件的参数使用说明"></a>怎样自定义命令源码文件的参数使用说明</h2><p>这有很多种方法，最简单的一种方式就是对变量 flag.Usage 重新赋值。flag.Usage 的类型是 func()，即一种无参数声明且无结果声明的函数类型。</p><p>对 flag.Usage 的赋值必须在调用 flag.Parse 函数之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flag.Usage = func() &#123;</span><br><span class="line">  fmt.Fprintf(os.Stderr, &quot;Usage of %s:\n&quot;, &quot;question&quot;)</span><br><span class="line">  flag.PrintDefaults()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行 go run demo.go --help 结果如下</span><br><span class="line"></span><br><span class="line">Usage of question:</span><br><span class="line">  -name string</span><br><span class="line">    The greeting object.(defalut &quot;everyone&quot;)</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>在深入一层，在调用 flag 包中的一些函数(比如 StringVar、Parse 等等)的时候，实际上是在调用 flag.CommandLine 变量的对应方法。</p><p>falg.CommandLine 相当于默认情况下的命令参数容器。所以，通过对 flag.CommandLine 重新赋值，可以更深层次的定制当前命令源码文件的参数使用说明。</p><p>注销掉 main 函数中的 flag.Usage 变量赋值语句，然后在 init 函数体的开始处添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag.CommandLine = flag.NewFlagSet(&quot;&quot;, flag.ExitOnError)</span><br><span class="line">flag.CommandLine.Usage = func() &#123;</span><br><span class="line">  fmt.Fprintf(os.Stderr, &quot;Usage of %s:\n&quot;, &quot;question&quot;)</span><br><span class="line">  flag.PrintDefaults()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行命令<code>go run demo.go --help</code>后，期输出会与上一次的输出一致。不过后面哦这种定制的方法更加灵活。比如，当将赋值的那条语句改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.CommandLine = flag.NewFlagSet(&quot;&quot;, flag.panicOnError)</span><br></pre></td></tr></table></figure><p>再运行<code>go run demo.go --help</code>命令就会产生另一种输出效果。这里传给<code>flag.NewFlagSet</code>函数的第二个参数值是<code>flag.PanicOnError</code>。</p><ul><li><code>flag.ExitOnError</code>的含义是，告诉命令参数容器，当命令后跟<code>--help</code>或者参数设置不正确的时候，在打印命令参数使用说明后以状态码 2 结束当前程序。状态码 2 代表用户错误地使用了命令。</li><li><code>flag.PanicOnError</code>的含义是抛出“运行时恐慌”</li></ul><p>下面更进一步，不用全局的 flag.CommandLine 变量，转而创建一个私有的命令参数容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cmdLine = flag.NewFlagSet(&quot;question&quot;, flag.ExitOnError)</span><br></pre></td></tr></table></figure><p>然后对 flag.StringVar 的调用替换为对 cmdLine.StringVar 调用，再把 <code>flag.Parse()</code> 替换为 <code>cmdLine.Parse(os.Args[1:])</code>。这样做就完全脱离了 flag.CommandLine。这样做的好处依然是更灵活的定制命令参数容器。但是定制完全不影响全局变量 flag.CommandLine。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://studygolang.com/articles/14209" target="_blank" rel="noopener">Go 语言命令源码文件</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript类型的细节</title>
      <link href="/2019/04/27/JavaScript%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2019/04/27/JavaScript%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h2 id="Undefined-与-Null"><a href="#Undefined-与-Null" class="headerlink" title="Undefined 与 Null"></a>Undefined 与 Null</h2><p>Undefined 类型表示未定义，它的类型只有一个值，就是 Undefined。任何变量在赋值前都是 Undefined 类型、值为 undefined，一般可以用全局变量 undefined 来表达这个值，或者用 void 运算将任意一个表达式变成 undefined 值。</p><p>因为 JavaScript 中 undefined 是一个变量，而并非一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，为了避免无意中被错改，建议使用<code>void 0</code>来获取 undefined 值。虽然现代浏览器都对这个变量的修饰符做了限定，不能修改，但是还是需要注意。</p><p>Null 类型也是只有一个值，就是 null，它的语义表示空值，<strong>表示定义了但是为空</strong>。与 undefined 不同，null 是 JavaScript 关键字，可以放心使用。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>JavaScript 中的字符是永远无法变更的，字符串一旦被构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。String 用于表示文本数据，String 有最大长度是<code>2^53 - 1</code>，这个在一般开发中是够用的，但是这个所谓的最大长度并不是我们理解中的字符数。因为 String 是字符串的 UTF-16 编码，我们字符串的操作<code>charAt</code>、<code>charCodeAt</code>、<code>length</code> 等方法针对的都是 UTF16 编码，所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p><blockquote><p>现行的字符集国际标准是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。Unicode 的码点通常用 U+码点 来表示，其中码点是十六进制的码点值。0-65535的码点被称为基本字符区域(BMP)。</p></blockquote><p>JavaScript 字符串把每个 UTF16 单元当作一个字符处理，所以超出 BMP 的字符时，应该格外小心。</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是为了表达几个额外的语言场景，规定了几个例外情况：</p><ul><li>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字</li><li>Infinity，无穷大</li><li>-Infinity，负无穷大</li></ul><p>另外，值得注意的是 +0 和 -0， 在加法运算中它们没有区别，但是除法的场合则需要特别留意区分，区分 +0 或 -0 的方式是检测 <code>1/x</code> 的结果是 Infinity 还是 -Infinity。</p><p>根绝双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。非整数的 Number 类型无法用 == 和 === 比较大小。这是浮点运算的特点，浮点运算的精度问题导致等式左右的结果并不是严格相等，而是相差了微小的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误的比较方法</span><br><span class="line">0.1 + 0.2 == 0.3 // false</span><br><span class="line"></span><br><span class="line">// 正确的比较方法</span><br><span class="line">Math.abs(0.1 + 0.2 -0.3) &lt;= Number.EPSILON // true 表示相等</span><br></pre></td></tr></table></figure><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol 是 ES6 中引入的新类型，它是一切字符串的对象key的集合，在 ES6 规范中国，整个对象系统被用 Symbol 重塑。这里只关注类型本身。</p><p>Symbol 可以具有字符串类型的描述，但是即使描述是相同的，Symbol 也不相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 使用全局 Symbol 函数创建 Symbol</span><br><span class="line">var mySymbol = Symbol(&quot;symbol description&quot;);</span><br><span class="line"></span><br><span class="line">// 使用 Symbol.iterator 来定义 for...of 在对象上的行为</span><br><span class="line">var o = new Object</span><br><span class="line">o[Symbol.iterator] = function () &#123;</span><br><span class="line">    var v = 0</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function () &#123;</span><br><span class="line">            return &#123; value: v++, done: v &gt; 10 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (var v of o) &#123;</span><br><span class="line">    console.log(v); // 0, 1 ... 9</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码中定义了 iterator 之后，用 for (var v of o) 就可以调用这个函数，然后可以根据函数的行为，产生一个 for ... of 的行为。</span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 的结构，key 可以是字符串或者 Symbol 类型。</p><p>JavaScript 中的几个基本类型的构造器：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>Symbol</li></ul><p>前三个是两用的，当跟 new 搭配的时候，产生对象，当直接调用时，它们表示强制类型转换。</p><p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p><p>JavaScript 语言设计上试图模糊对象和基本类型之间的关系，日常中可以把对象的方法在基本类型上使用，甚至在原型上添加的方法，都可以应用于基本类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在基本类型上调用方法</span><br><span class="line">console.log(&quot;abc&quot;.charAt(0)); // a</span><br><span class="line"></span><br><span class="line">// 在 Symbol 原型上添加方法，在任何 Symbol 类型变量都可以调用</span><br><span class="line">Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">var a = Symbol(&quot;a&quot;);</span><br><span class="line">console.log(typeof a); // symbol，a 并非对象</span><br><span class="line">a.hello(); // hello，有效</span><br></pre></td></tr></table></figure><p><code>.</code>运算符提供了装箱操作，它会根据基础类型构造一个临时的包装对象，使得我们能在基础类型上调用对应对象的方法。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算符会先进行类型转换。大部分类型转换符合直觉，但是如果不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。</p><p>类型转换规则表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|         |    Null   |  Undefined  | Boolean(True) | Boolean(False) |      Number    |     String     |  Symbol   | Object |</span><br><span class="line">| ------- | --------- | ----------- | ------------- | -------------- | -------------- | -------------- | --------- | ------ |</span><br><span class="line">| Boolean |   FALSE   |    FALSE    |       -       |        -       |  0/NaN-false   |    &quot;&quot;-fase     |   TRUE    |  TRUE  |</span><br><span class="line">|  Number |     0     |      NaN    |       1       |        0       |       -        | StringToNumber | TypeError | 拆箱转换 |</span><br><span class="line">|  String |  &quot;null&quot;   | &quot;undefined&quot; |     TRUE      |      FALSE     | NumberToString |       -        | TypeError | 拆箱转换 |</span><br><span class="line">|  Object | TypeError |  TypeError  |    装箱转换    |      装箱转换    |     装箱转换    |     装箱转换    |  装箱转换   |   -    |</span><br></pre></td></tr></table></figure><p>在上面的表格中，较为复杂的是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。</p><h3 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h3><p>字符串到数字的类型转换，存在一个语法结构，类型转换支持支持十进制、二进制、八进制和十六进制，比如：</p><ul><li>30</li><li>0b111</li><li>0o13</li><li>0xFF</li></ul><p>此外，JavaScript 支持的字符串语法还包括科学计数法，可以使用大写或者小写 e 来表示：</p><ul><li>1e3</li><li>-1e-2</li></ul><p>需要注意的是，在 StringToNumber 的情况下，parseInt 和 parseFloat 在不传入参数的情况下，只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头 的数字作为 8 进制前缀，这是很多错误的涞源。所以，在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。</p><h3 id="NumnberToString"><a href="#NumnberToString" class="headerlink" title="NumnberToString"></a>NumnberToString</h3><p>在较小的范围内，数字到字符串的转换是完全符合直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示，保证了产生的字符串不会过长。</p><h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓的装箱转换，正是把基本类型转换为对应一个对象。全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 利用 call 方法来强制产生装箱</span><br><span class="line">var symbolObject = (function() &#123;return this;&#125;).call(Symbol(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">console.log(typeof symbolObject) // object</span><br><span class="line">console.log(symbolObject instanceof Symbol) // true</span><br><span class="line">console.log(symbolObject.constructor == Symbol) // true</span><br></pre></td></tr></table></figure><p>装箱机制会频繁产生临时对象，在一些性能要求较高的场景下，应该尽量避免对基本类型做装箱转换。</p><p>使用内置的 Object 函数，可以在 JavaScript 代码中显式调用装箱能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var symbolObject = Object(Symbol(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(symbolObject)); // [Object Symbol]</span><br></pre></td></tr></table></figure><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p><h3 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h3><p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。对象到 String 和 Number 的转换都是把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><p>拆箱转换都会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 到 Number 的拆箱转换</span><br><span class="line">var o = &#123;</span><br><span class="line">    valueOf: () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,</span><br><span class="line">    toString: () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0 * 2</span><br><span class="line"></span><br><span class="line">// valueOf</span><br><span class="line">// toString</span><br><span class="line">// TypeError</span><br><span class="line"></span><br><span class="line">// 到 String 的拆箱转换</span><br><span class="line"></span><br><span class="line">String(o)</span><br><span class="line"></span><br><span class="line">// toString</span><br><span class="line">// valueOf</span><br><span class="line">// TypeError</span><br></pre></td></tr></table></figure><p>这里调用 toString 与 调用 valueOf 的顺序，与规范中的内部实现有关。规范指出，类型转换的内部实现是通过<code>ToPrimitive (input [, PreferredType])</code>方法进行转换的，这个方法的作用就是将 input 转换成一个非对象类型。参数 preferredType 进来，默认的是“number”，如果值是“string”，那就先执行“toString”，后执行“valueOf”，如果参数是“string”，则调换顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 规范中加法操作没有传递值，所以默认参数“number”起效</span><br><span class="line">o + &quot;string&quot;</span><br><span class="line"></span><br><span class="line">// valueOf</span><br><span class="line">// toString</span><br><span class="line">// TypeError</span><br></pre></td></tr></table></figure><p>在 ES6 之后，允许对象通过显示指定 @@toPrimitive Symbol 来覆盖原有的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    valueOf: () =&gt; &#123;console.log(&quot;valueOf&quot;); return &#123;&#125;&#125;,</span><br><span class="line">    toString: () =&gt; &#123;console.log(&quot;toString&quot;); return &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[Symbol.toPrimitive] = () =&gt; &#123;console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(o + &quot;&quot;)</span><br><span class="line"></span><br><span class="line">// toPrimitive</span><br><span class="line">// hello</span><br></pre></td></tr></table></figure><h3 id="运行时类型"><a href="#运行时类型" class="headerlink" title="运行时类型"></a>运行时类型</h3><p>运行时类型(标准中的规定)与 typeof 运算返回的操作数的类型比较</p><table><thead><tr><th>示例表达式</th><th>typeof 结果</th><th>运行时类型</th></tr></thead><tbody><tr><td>null</td><td>object</td><td>Null</td></tr><tr><td>{}</td><td>object</td><td>Object</td></tr><tr><td>(function(){})</td><td>function</td><td>Object</td></tr><tr><td>3</td><td>number</td><td>Number</td></tr><tr><td>“ok”</td><td>string</td><td>String</td></tr><tr><td>true</td><td>boolean</td><td>Boolean</td></tr><tr><td>void 0</td><td>undefined</td><td>Undefined</td></tr><tr><td>Symbol(“a”)</td><td>symbol</td><td>Symbol</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GOPATH 和工作区</title>
      <link href="/2019/04/21/GOPATH%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8C%BA/"/>
      <url>/2019/04/21/GOPATH%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在成功安装自己对应操作系统的 go 语言安装包以后，还需要配置三个环境变量：</p><ul><li>GOROOT：go 语言安装根目录的路径</li><li>GOPATH：若干工作区目录的路径，是自己定义的工作空间</li><li>GOBIN：go 程序生成的可执行文件的路径</li></ul><p>go 命令依赖一个重要的环境变量：GOPATH。</p><p>GOPATH 允许有多个目录，当有多个目录时，请注意分隔符，多个目录的时候 windows 是分号<code>;</code>，当有多个 GOPATH 时，默认将<code>go get</code>获取的包存放在第一个目录下。</p><h2 id="源码的组织方式"><a href="#源码的组织方式" class="headerlink" title="源码的组织方式"></a>源码的组织方式</h2><p>go 语言的源码是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。通俗来讲就是一个目录下面只能有一个 package。由于目录可以有子目录，所以代码包也可以有子包。</p><p>一个代码包中可以包含任意个<code>.go</code>为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。代码包的名称一般会与源码文件所在的目录名保持一致。但是 go 语言没有做强制规定，如果不同名，那么构建、安装的过程中会以代码包名称为准。 </p><p>每个代码包都会有导入路径，代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在工作区中，一个代码包的导入路径就是从 src 子目录开始，到该包的实际存储位置的相对路径。</p><h2 id="代码目录结构规划"><a href="#代码目录结构规划" class="headerlink" title="代码目录结构规划"></a>代码目录结构规划</h2><p>GOPATH 下的 src 目录就是接下来开发程序的主要工作目录，也就是我们的工作区，所有的源码都是放在这个目录下面的，一般的做法就是一个目录一个项目。</p><p>例如：<code>$GOPATH/src/mymath</code>表示 mymath 这个应用包或者可执行应用，这个根据 package 是 main 还是其他来决定，main 是可执行应用，其他就是应用包。</p><p>GOPATH 目录约定有三个子目录：</p><ul><li><code>src</code> 存放源代码（比如：.go .c .h .s等）按照go的默认约定，是<code>go run</code>、<code>go install</code>等命令的当前工作路径（即在此路径下执行上述命令）</li><li><code>pkg</code> 编译生成的中间文件（归档文件，程序生成后的静态库文件）</li><li><code>bin</code> 编译后生成的可执行文件（为了方便，可以把此目录加入到<code>$PATH</code>变量中，如果有多个 GOPATH，那么使用<code>${GOPATH//://bin:}/bin</code>添加所有的 bin 目录）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 一个整体开发目录</span><br><span class="line">go_project // go_project 为 GOPATH 目录</span><br><span class="line">  -- bin</span><br><span class="line">    -- myapp1</span><br><span class="line">    -- myapp2</span><br><span class="line">  --  pkg</span><br><span class="line">  -- src</span><br><span class="line">    -- myapp1 // project1</span><br><span class="line">      -- models</span><br><span class="line">      -- controllers</span><br><span class="line">      -- others</span><br><span class="line">      -- main.go</span><br><span class="line">    -- myapp2 // project2</span><br><span class="line">      -- models</span><br><span class="line">      -- controllers</span><br><span class="line">      -- others</span><br><span class="line">      -- main.go</span><br></pre></td></tr></table></figure><p>当我们执行<code>go install</code>命令来安装一个项目的源码以后，对应工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者直接放置到该工作区的 bin 子目录中。</p><p>安装过程中可能会产生编译后生成的中间文件，产生的中间文件与代码包的名字相同，放置它的相对目录就是代码包的导入路径的直接父级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 导入路径</span><br><span class="line">github.com/project/init</span><br><span class="line"></span><br><span class="line">// 中间文件的存放路径</span><br><span class="line">github.com/project</span><br></pre></td></tr></table></figure><p>中间文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称时由构建的目标操作系统、下划线和目标计算机架构的代码组成的。例如构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平添相关目录就是 linux_amd64。</p><h2 id="理解构建和安装-go-程序的过程"><a href="#理解构建和安装-go-程序的过程" class="headerlink" title="理解构建和安装 go 程序的过程"></a>理解构建和安装 go 程序的过程</h2><p>构建使用<code>go build</code>,安装使用<code>go install</code>。构建和安装代码包都会执行编译，打包操作，并且，这些操作生成的任何文件都会被先保存在某个临时的目录中。</p><p>如果构建的是库源码文件，那么操作后产生的结果文件只会存放于临时目录中。这里的构建的主要意义在于检查和验证。如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。</p><p>安装操作会先执行构建，然后还会进行链接操作，如果安装的是库源码文件，结果文件会被搬运到它所在的工作区的 pkg 目录下的子目录中；如果安装的是命令源码文件，那么结果文件会被搬运到它所在的工作区的 bin 目录中，或者环境变量 GOBIN 指向的目录中。</p><h2 id="GOPATH-多工作区问题"><a href="#GOPATH-多工作区问题" class="headerlink" title="GOPATH 多工作区问题"></a>GOPATH 多工作区问题</h2><p>如果设置了多个工作区，那么查找依赖包是以怎样的顺序进行的？</p><p>例如 a 依赖 b，b 依赖 c。那么会先查找 c 包，那么在工作区是如何查找这个依赖包 c 的哪？首先在，查找依赖包的时候，总是会先查找 GOROOT 目录，也就是 go 语言的安装目录，如果没有找到依赖的包，才会到工作区区找相应的包。</p><p>在工作区中是按照设置的先后顺序来查找的，也就是会从第一个开始，依次查找，如果找到就不再继续查找，如果没有找到，就报错了。<code>go get</code>会下载代码到 src 目录，但是只会下载到第一个工作区目录。</p><p>在 go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似”github.com/xxxx/item”的字符串对应包的导入路径。go 语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。一个导入路径代表一个目录中的一个或多个 go 源文件。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://cloud.tencent.com/developer/article/1339642" target="_blank" rel="noopener">工作区和GOPATH的注意事项</a><br><a href="https://cloud.tencent.com/developer/article/1200612" target="_blank" rel="noopener">Go 语言之讲解 GOROOT、GOPATH、GOBIN</a><br><a href="https://cloud.tencent.com/developer/article/1339789" target="_blank" rel="noopener">GOPATH有多工作区的问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git基础</title>
      <link href="/2019/04/07/Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/04/07/Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h2><p>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>根据不同的系统，选择下载，之后选择默认配置安装即可。</p><h2 id="2-使用之前的最小配置"><a href="#2-使用之前的最小配置" class="headerlink" title="2. 使用之前的最小配置"></a>2. 使用之前的最小配置</h2><p>配置user信息，一般配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 配置全局用户信息</span><br><span class="line">git config --global user.name &apos;your_name&apos;</span><br><span class="line">git config --global user.email &apos;your_email@domain.com&apos;</span><br><span class="line"></span><br><span class="line">// config的三个作用域</span><br><span class="line">git config --local // 只对某个仓库有效，缺省等同于local（优先级大于global）</span><br><span class="line">git config --global // 对当前用户的所有仓库有效</span><br><span class="line">git config --system // 对系统所有登录的用户有效（不常用）</span><br></pre></td></tr></table></figure><h2 id="3-建立代码仓库"><a href="#3-建立代码仓库" class="headerlink" title="3. 建立代码仓库"></a>3. 建立代码仓库</h2><p>一般有两种场景：</p><ul><li>把已有的项目代码纳入Git管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 项目代码所在的文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>新建的项目直接用Git管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 某个文件夹</span><br><span class="line">git init your_project // 会在当前路径下创建和项目名称相同的文件夹</span><br><span class="line">cd your_project</span><br></pre></td></tr></table></figure><h2 id="4-工作区和暂存区"><a href="#4-工作区和暂存区" class="headerlink" title="4. 工作区和暂存区"></a>4. 工作区和暂存区</h2><p>在工作目录中修改内容产生的变更通过<code>git add files</code>会进入暂存区，暂存区的内容已经被git所管理，暂存区的内容通过<code>git commit</code>命令提交以后就会被计入版本历史当中。</p><h2 id="5-commit、tree和blob三个对象之间的关系"><a href="#5-commit、tree和blob三个对象之间的关系" class="headerlink" title="5. commit、tree和blob三个对象之间的关系"></a>5. commit、tree和blob三个对象之间的关系</h2><p>日常开发中，会通过<code>git add files</code>将开发完成的内容先放入暂存区中，暂存区中的内容会在一次提交以后计入版本历史中，这个操作通过<code>git commit</code>来完成。</p><p>当我们提交以后会Git会为我们生成一个提交对象。对象记录了我们这一次提交的状况，包括上一次提交是什么，下一次提交是什么，以及作者和提交人。其中tree对象表示我们提交的时的整个工作目录的一个文件快照，用来记录当前提交时的文件的内容，包括我们所作的变更。整个文件系统对应为一个tree结构，文件夹对应为一个tree对象，文件对应为一个blob对象，可以通过<code>git cat-file -t &quot;hash value&quot;</code>来查看文件的类型（包括：commit，tree，blob），通过<code>git cat-file -p &quot;hash value&quot;</code>来查看文件的内容。</p><p><strong>Git对于相同的文件只会存一个blob</strong>。不同的commit的区别是commit、tree和有差异的blob，多数未变更的文件对应的blob都是相同的。这么设计对于版本管理系统来说可以节省很多存储空间。其次，Git还有增量存储的机制，针对差异很小的blob所设计。</p><h2 id="6-分离头指针"><a href="#6-分离头指针" class="headerlink" title="6. 分离头指针"></a>6. 分离头指针</h2><p>本质上，HEAD是某一次提交的引用，也就是一串哈希值。通常情况下，HEAD总是指向某个分支距离当前最近的一次提交。当通过<code>git checkout &quot;hash value&quot;</code>命令从某一次提交上尝试切换分支的时候，就会处于分离头指针（detached HEAD）的状态。在当前状态下的修改，会处于没有分支的状态，如果不创建分支，这些修改的代码会被Git当作垃圾清理掉，并且不会出现在版本历史中；如果想要保存修改的内容需要通过命令<code>git branch &lt;new-branch-name&gt;</code>创建一个分支。</p><p><strong>基于分支的变更提交以后会被保存下来，处于分离头指针状态的分支需要创建分支以后才会被保存下来。这种操作看似危险但是是很有必要的。因为在实际项目中我们很可能需要基于某一次提交做变更，这个时候需要特别注意，如果没有创建分支，那么变更将会丢失。</strong></p><h2 id="7-常用的命令与工具"><a href="#7-常用的命令与工具" class="headerlink" title="7. 常用的命令与工具"></a>7. 常用的命令与工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git status // 查看当前目录下的文件的状态</span><br><span class="line">git reset --hard //清除暂存区的内容</span><br><span class="line">git mv &lt;filename1&gt; &lt;filename2&gt; //变更文件名，将文件filename1变更为filename2</span><br><span class="line">git log -[n] // 查看最新的某几条日志</span><br><span class="line">git log --graph // 查看图形化的日志</span><br><span class="line">git diff // 用于比较差异</span><br><span class="line">gitk // 图形化界面，用于查看版本的历史</span><br><span class="line">git add files // 将文件加入到暂存区</span><br><span class="line">git commit -m &quot;message&quot; // 提交</span><br><span class="line">git push // 将当前的变更push到远程的代码仓库</span><br><span class="line">git pull // 从远程的代码仓库拉取最新的代码</span><br><span class="line">git checkout // 切换分支</span><br><span class="line">git checkout -b &lt;new-branch-name&gt; &lt;base-branch&gt; // 基于某个分支创建一个新分支</span><br><span class="line">git branch &lt;new-branch-name&gt; // 创建一个新的分支</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 实现文本单行居中，多行靠左</title>
      <link href="/2019/03/31/CSS%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E5%8D%95%E8%A1%8C%E5%B1%85%E4%B8%AD%E5%A4%9A%E8%A1%8C%E9%9D%A0%E5%B7%A6/"/>
      <url>/2019/03/31/CSS%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E5%8D%95%E8%A1%8C%E5%B1%85%E4%B8%AD%E5%A4%9A%E8%A1%8C%E9%9D%A0%E5%B7%A6/</url>
      
        <content type="html"><![CDATA[<p>实现文本单行居中，多行靠左利用了<code>display: inline-block</code>的特性。外边使用一个块级元素，并设置居中对齐，这样的话，块级元素内的行内元素是会居中对齐的。里边使用一个行内块级元素，整个行内块级元素会相对于外层的<code>div</code>呈现出行内元素的特性，因此会居中。然后设置自身文本靠左对齐。多行的情况下由于文本撑满了外部的容器，因此看上去是靠左的，实际上一直都是相对于容器居中。talk is cheap，请看下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;span&gt;这里是文字&lt;/span&gt;   </span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">// css</span><br><span class="line">div &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  text-align: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RESTful架构详解</title>
      <link href="/2019/01/20/RESTful%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/01/20/RESTful%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是REST"><a href="#1-什么是REST" class="headerlink" title="1. 什么是REST"></a>1. 什么是REST</h2><p><strong><code>REST</code>全称是Representational State Transfer, 中文意思是表述性状态转移。指的是一组架构约束条件和原则。</strong>如果一个架构符合REST的约束条件和原则，我们就可以称它为<code>RESTful</code>架构。</p><h2 id="2-理解RESTful"><a href="#2-理解RESTful" class="headerlink" title="2. 理解RESTful"></a>2. 理解RESTful</h2><p>结合<code>REST</code>原则，围绕资源展开讨论，从资源的<strong>定义、获取、表述、关联、状态变迁</strong>等角度，列举一些关键概念并加以解释。</p><ul><li>资源与URl</li><li>统一资源接口</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移</li></ul><h3 id="2-1-资源与URl"><a href="#2-1-资源与URl" class="headerlink" title="2.1 资源与URl"></a>2.1 资源与URl</h3><p><code>REST</code>全称是表述性状态转移，那究竟指的是什么的表述？其实指的就是资源的。<strong>任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体（例如手机号码），也可以只是一个抽象概念（例如价值）</strong>。下面是一些资源的例子：</p><ul><li>某用户的手机号码</li><li>某用户的个人信息</li><li>最多用户订购的GPRS套餐</li><li>两个产品之间的依赖关系</li><li>某用户可以办理的优惠套餐</li><li>某手机号码的潜在价值</li></ul><p>要让一个资源可以被识别，需要有个唯一的标识，再Web中这个唯一标识就是URl(Uniform Resource Identifier)。URl既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用<code>URl</code>来表示，那它就不能算是一个资源，只能算是资源的一些信息而已。<code>URl</code>的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。</p><ul><li><a href="https://github.com/git" target="_blank" rel="noopener">https://github.com/git</a></li><li><a href="https://github.com/git/git" target="_blank" rel="noopener">https://github.com/git/git</a></li><li><a href="https://github.com/git/git/blob/master/block-sha1/sha1.h" target="_blank" rel="noopener">https://github.com/git/git/blob/master/block-sha1/sha1.h</a></li><li><a href="https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08" target="_blank" rel="noopener">https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08</a></li><li><a href="https://github.com/git/git/pulls" target="_blank" rel="noopener">https://github.com/git/git/pulls</a></li><li><a href="https://github.com/git/git/pulls?state=closed" target="_blank" rel="noopener">https://github.com/git/git/pulls?state=closed</a></li><li><a href="https://github.com/git/git/compare/master…next" target="_blank" rel="noopener">https://github.com/git/git/compare/master…next</a></li></ul><p><code>URl</code>设计上的一些技巧：</p><ul><li>使用<code>_</code>或<code>-</code>来让<code>URl</code>可读性更好</li><li>使用<code>/</code>来表示资源的层级关系</li><li>使用<code>?</code>用来过滤资源</li><li>使用<code>,</code>或<code>;</code>可以用来表示同级资源的关系</li></ul><h4 id="统一资源接口"><a href="#统一资源接口" class="headerlink" title="统一资源接口"></a>统一资源接口</h4><p><strong><code>RESTful</code>架构应该遵循统一接口原则，统一接口包含了一组受限的预定义操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。</strong>接口应该使用标准的<code>HTTP</code>方法如，<code>GET</code>，<code>PUT</code>和<code>POST</code>，并遵循这些方法的语义。</p><p>如果按照<code>HTTP</code>方法的语义来暴露资源，那么接口将会拥有安全性和幂等性（简单来说一个操作多次执行与一次执行产生的结果一致）的特性，例如<code>GET</code>和<code>HEAD</code>请求都是安全的，无论请求多少次，都不会改变服务器状态。而<code>GET</code>、<code>HEAD</code>、<code>PUT</code>和<code>DELETE</code>请求都是幂等的，无论对资源操作多少次，结果总是一样的，后面的请求并不会产生比第一次更多的影响。</p><p>下面列出了<code>GET</code>，<code>DELETE</code>，<code>POST</code>和<code>PUT</code>的经典用法：</p><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><ul><li>安全且幂等</li><li>获取表示</li><li>变更时获取表示（缓存）</li><li>200（OK）- 表示已经在响应中发出</li><li>204（无内容）- 资源有空表示</li><li>301（Moved Permanently）- 资源的URl已被更新</li><li>303（See Other）- 其他（如，负载均衡）</li><li>304（not modified）- 资源未更改（缓存）</li><li>400（bad request）- 指代坏请求（如，参数错误）</li><li>404（not found）- 资源不存在</li><li>406（not acceptable）- 服务端不支持所需表示</li><li>500（internal server error）- 通用错误响应</li><li>503（Service Unavailable）- 服务端当前无法处理请求</li></ul><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><ul><li>不安全且不幂等</li><li>使用服务端管理的（自动产生）的实例号创建资源</li><li>创建子资源</li><li>部分更新资源</li><li>如果没有被修改，则不更新资源（乐观锁）</li><li>200（OK）- 如果现有资源已被更改</li><li>201（created）- 如果新资源被创建</li><li>202（accepted）- 已经接受处理请求但尚未完成（异步处理）</li><li>301（Moved Permanently）- 资源的URl被更新</li><li>303（See Other）- 其他（如，负载均衡）</li><li>400（bad request）- 指代坏请求</li><li>404（not found）- 资源不存在</li><li>406（not acceptable）- 服务端不支持所需表示</li><li>409（conflict）- 通用冲突</li><li>412（Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li><li>415（unsupported media type）- 接受到的表示不受支持</li><li>500（internal server error）- 通用错误响应</li><li>503（Service Unavailable）- 服务当前无法处理请求</li></ul><h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><ul><li>不安全但幂等</li><li>用客户端管理的实例号创建一个资源</li><li>通过替换的方式更新资源</li><li>如果未被修改，则更新资源（乐观锁）</li><li>200（OK）- 如果已存在资源被更改</li><li>201（created）- 如果新资源被创建</li><li>301（Moved Permanently）- 资源的URl已更改</li><li>303（See Other）- 其他（如，负载均衡）</li><li>400（bad request）- 指代坏请求</li><li>404（not found）- 资源不存在</li><li>406（not acceptable）- 服务端不支持所需表示</li><li>409（conflict）- 通用冲突</li><li>412（Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li><li>415（unsupported media type）- 接受到的表示不受支持</li><li>500（internal server error）- 通用响应错误</li><li>503（Service Unavaliable）- 服务当前无法处理请求</li></ul><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><ul><li>不安全但幂等</li><li>删除资源</li><li>200（OK）- 资源已被删除</li><li>301（Moved Permanently）- 资源的URl已更改</li><li>303（See Other）- 其他，如负载均衡</li><li>400（bad request）- 指代坏情去</li><li>404（not found）- 资源不存在</li><li>409（conflict）- 通用冲突</li><li>500（internal server error）- 通用响应错误</li><li>503（Service Unavaliable）- 服务器当前无法处理请求</li></ul><p>下面我们来看一些实践中常见的问题：</p><ul><li><p><code>POST</code>和<code>PUT</code>用于创建资源时有什么区别？<br><code>POST</code>和<code>PUT</code>在创建资源的区别在于，所创建的资源的名称（URl）是否由客户端决定。例如为我的博文增加一个java的分类，生成的路径就是分类名<code>/categories/java</code>，那么就可以采用<code>PUT</code>方法。不过很多人直接把<code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>DELETE</code>直接对应上<code>CRUD</code>，例如在一个典型的<code>rails</code>实现的<code>RESTful</code>应用中就是这么做的。</p></li><li><p>客户端不一定都支持这些<code>HTTP</code>方法吧？<br>的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持<code>GET</code>和<code>POST</code>两种方法。在实践上，客户端和服务端都可能需要做一些妥协。</p></li><li><p>统一接口是否意味着不能扩展带特殊语义的方法？<br>统一接口不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。</p></li><li><p>统一资源接口对URl有什么指导意义？<br>统一资源接口要求使用标准的<code>HTTP</code>方法对资源进行操作，所以<code>URl</code>只应该来表示资源的名称，而不应该包括资源的操作。通俗来说，<code>URl</code>不应该使用动作来描述。例如，下面是一些不符合接口要求的<code>URl</code>：</p><ul><li>GET/getUser/1</li><li>POST/createUser</li><li>PUT/updateUser/1</li><li>DELETE/deleteUser/1</li></ul></li></ul><ul><li><p>如果<code>GET</code>请求增加计数器，这是违反安全性？<br>安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。但客户端不是为了追求副作用而发出这些<code>GET</code>或<code>HEAD</code>请求的，产生副作用是服务端自做主张的。另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。</p></li><li><p>直接忽视缓存可取吗？<br>即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。最简单的做法就是在你的<code>HTTP</code>响应里增加这样一个报头：<code>Cache-control:no-cache</code>。但是，同时，你也对失去了高效的缓存与再验证的支持（使用Etag等机制）。对于客户端来说，在为一个<code>REST</code>式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。</p></li><li><p>响应代码的处理有必要吗？<br>HTTP的响应代码可用于应付不同场合，正确使用这些状态码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。例如：201（”Created”）响应代码表明已经创建了一个新的资源，其URl在Location响应报头里。<br>假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。</p></li></ul><h3 id="2-3-资源的表述"><a href="#2-3-资源的表述" class="headerlink" title="2.3 资源的表述"></a>2.3 资源的表述</h3><p><strong>客户端获取的只是资源的表述而已。资源在外界的具体呈现，可以有多种表述（或称为表现、表示）形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。</strong>例如文本资源可以采用html、xml、json等格式，图片可以使用png、或JPG展现出来。</p><p>资源的表述包括数据和描述数据的元数据，例如HTTP头<code>Content-Type</code>就时这样一个元数据属性。</p><p>那么客户端如何知道服务端提供那种表述形式哪？</p><p>答案时可以通过HTTP内容协商，客户端可以通过<code>Accept</code>头请求一种特定格式的表述，服务端则通过<code>Content-Type</code>告诉客户端资源的表述形式。</p><p>下面来看一些实践上的常见设计：</p><ul><li><p>在URL里面带上版本号，例如：<br><a href="http://api.example.com/1.0/foo" target="_blank" rel="noopener">http://api.example.com/1.0/foo</a><br><a href="http://api.example.com/1.2/foo" target="_blank" rel="noopener">http://api.example.com/1.2/foo</a><br><strong>因为不同的版本可以理解成同一种资源的不同表现形式，所以应该采用同一个<code>URl</code>。</strong>版本号可以在HTTP请求头信息的<code>Accept</code>字段中进行区分。<br>Accept: vnd.example-com.foo+json; version=1.0<br>Accept: vnd.example-com.foo+json; version=1.1<br>Accept: vnd.example-com.foo+json; version=2.0</p></li><li><p>使用<code>URl</code>后缀来区分表述格式<br>像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但<strong>混淆了资源的名称和资源的表述形式</strong>。还是应该优先使用内容协商来区分表述格式。</p></li><li><p>如何处理不支持的表述格式<br>当服务器不支持所请求的表述格式，它应该返回一个HTTP 406响应，表示拒绝处理该请求。</p></li></ul><h3 id="2-4-状态的转移"><a href="#2-4-状态的转移" class="headerlink" title="2.4 状态的转移"></a>2.4 状态的转移</h3><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”</strong>。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源</strong>。</p><p>综合上面的内容，总结一下什么是<strong>RESTful</strong>架构：</p><ul><li><strong>每一个<code>URl</code>代表一种资源</strong></li><li><strong>客户端和服务器之间，传递这种资源的某种表现层</strong></li><li><strong>客户端通过四个HTTP动词，对服务器资源进行操作，实现“表现层状态转移”</strong>。</li></ul><h3 id="2-5-参考内容"><a href="#2-5-参考内容" class="headerlink" title="2.5 参考内容"></a>2.5 参考内容</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">RESTful API 最佳实践</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></li><li><a href="https://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="noopener">RESTful架构详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于浏览器记住密码的一些探索</title>
      <link href="/2018/12/19/%E5%85%B3%E4%BA%8E%E9%98%B2%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/"/>
      <url>/2018/12/19/%E5%85%B3%E4%BA%8E%E9%98%B2%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>网站升级为https协议以后都可以很好的解决这个问题，但是对于不是https协议的网站也想实现这个相对来说是比较困难的。存在各种兼容性问题，尤其是360安全浏览器。</p><p>360安全浏览器会选择所有<code>type=&quot;password&quot;</code>类型的<code>input</code>，类似<code>jQuery</code>选择器的做法。然后在获取焦点的同时，将识别<code>type=&quot;password&quot;</code>的<code>input</code>填充上浏览器记住的密码，然后自然而然的将上一个<br><code>input</code>填充为帐号。如果仅仅是在获取焦点的时候将输入框的不能输入状态变为输入状态，是不能够适用于360安全浏览器（当然还是可以骗过一些浏览器）。解决的思路是在原有生效的帐号密码的输入框的上方再添加一组输入框，而且是可以输入的。用绝对定位设置层级，将他们放到用户碰不到的地方。然后初始的时候假的输入框可以输入，真的不可以输入，真的输入框在获取焦点的时候变为可以输入。这样的话360安全浏览器会在第一时间将记住的密码填充到假的输入框中，此时真的输入框是不能输入的。当用户输入真的输入框的时候，360安全浏览器已经检测到填充成功，就不会再来填充下方的输入框了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div class=&quot;hiddenInput&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;showInput&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;password&quot; readonly onfocus=&quot;this.removeAttribute(&apos;readonly&apos;)&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- CSS --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  /* .hiddenInput 通过定位，然后设置z-index将假的输入框放到用户触摸不到的地方</span><br><span class="line">  具体代码不展示，实现方式较多 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
